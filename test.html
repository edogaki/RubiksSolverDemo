<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <title>Rubik's Cube Solver</title> -->
    <title>TEST</title>
    <meta name="description"
        content="Fast solver for Rubik's Cube cross, XCross, EOCross, free pair, pseudo F2L, and last layer. ">
    <!-- <script async src="https://www.googletagmanager.com/gtag/js?id=G-MXJH30352W"></script> -->
    <script async src="src/min2phase.js/min2phase.js"></script>
    <script async src="src/functions/list.js"></script>
    <script src="src/functions/functions.js"></script>
    <!-- <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-MXJH30352W');
    </script> -->
    <style>
        header {
            padding: 2px;
            text-align: center;
            cursor: pointer;
            background-color: #121212;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 0;
            background-color: #121212;
        }

        h1 {
            font-family: Arial, sans-serif;
            font-size: 24px;
            text-align: center;
            color: #ffffff;
        }

        h2,
        label {
            font-family: Arial, sans-serif;
            font-size: 20px;
            text-align: left;
            color: #ffffff;
        }

        textarea {
            font-family: Arial, sans-serif;
            width: 100%;
            max-width: 700px;
            height: 200px;
            font-size: 20px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #41417f;
            border-radius: 4px;
            box-sizing: border-box;
            background-color: #1e1e1e;
            color: #ffffff;
        }

        input {
            font-family: Arial, sans-serif;
            width: 100%;
            max-width: 100px;
            height: 40px;
            font-size: 20px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #41417f;
            border-radius: 4px;
            box-sizing: border-box;
            background-color: #1e1e1e;
            color: #ffffff;
        }

        select {
            font-family: Arial, sans-serif;
            max-width: 200px;
            font-size: 20px;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ffffff;
            border-radius: 4px;
            box-sizing: border-box;
            background-color: #1e1e1e;
            color: #ffffff;
            cursor: pointer;
        }

        .button {
            font-family: Arial, sans-serif;
            width: 100%;
            font-size: 20px;
            padding: 10px;
            background-color: #56567c;
            color: #ffffff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .medium {
            max-width: 100px;
        }

        .small {
            max-width: 40px;
        }

        button:hover {
            background-color: #4a4a6d;
        }

        summary {
            box-sizing: border-box;
            display: block;
            font-family: Arial, sans-serif;
            padding: 10px;
            font-size: 20px;
            color: #ffffff;
            width: 100%;
            max-width: 750px;
            cursor: pointer;
        }

        details {
            border: 1px solid #41417f;
            padding: 5px;
            margin: 10px 0;
        }

        .analyzer_result {
            color: #ffffff;

        }

        .panalyzer_result {
            color: #ffffff;
        }

        .pair_analyzer_result {
            color: #ffffff;
        }

        .pair_panalyzer_result {
            color: #ffffff;
        }

        .eo_analyzer_result {
            color: #ffffff;
        }

        table,
        ptable,
        pair_table,
        pair_ptable,
        eo_table {
            width: 100%;
            max-width: 750px;
            max-height: 400px;
            overflow-x: auto;
            display: block;
        }

        th,
        td {
            text-align: left;
            white-space: nowrap;
            color: #ffffff;
            font-family: Arial, sans-serif;
            font-size: 20px;
            min-width: 40px;
            min-height: 40px;
        }

        td {
            cursor: pointer;
        }

        .table-res_table_wrapper {
            max-height: 400px;
            overflow: auto;
            border: 1px solid #fff;
        }

        #move_available_table_wrapper {
            overflow-x: auto;
            max-width: 100%;
            position: relative;
        }

        テーブル本体のスタイル #move_available_table {
            border-collapse: collapse;
            max-height: 400px;
            overflow: auto;
            border: 1px solid #fff;
        }

        #move_available_table tbody th {
            position: -webkit-sticky;
            position: sticky;
            left: 0;
            background: #1e1e1e;
            z-index: 1;
            border-right: 1px solid #ccc;
        }

        #move_available_table thead th:first-child {
            position: -webkit-sticky;
            position: sticky;
            left: 0;
            background: #1e1e1e;
            z-index: 2;
        }

        thead th {
            position: sticky;
            top: 0;
            background: #1e1e1e;
            z-index: 2;
        }

        .hidden {
            display: none;
        }

        .hidden_small {
            visibility: hidden;
        }

        a,
        pre {
            color: #ffffff;
            font-family: Arial, sans-serif;
            font-size: 20px;
        }

        twisty-player {
            margin: 0;
            width: 100%;
            max-width: 600px;
        }

        .custom-checkbox {
            display: none;
        }

        .custom-checkbox+label {
            position: relative;
            padding-left: 33px;
            cursor: pointer;
            font-size: 20px;
            color: #ffffff;
            margin-right: 10x;
        }

        .custom-checkbox+label:before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: 2px solid #41417f;
            background-color: #1e1e1e;
        }

        .custom-checkbox:checked+label:before {
            background-color: #41417f;
            border-color: #41417f;
        }

        .custom-checkbox:checked+label:after {
            content: '';
            position: absolute;
            left: 9px;
            top: 5px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        fieldset {
            border: 1px solid #121212;
            border-radius: 4px;
            padding: 10px;
            background-color: #121212;
        }
    </style>
</head>

<body>
    <header id="header">
        <h1>Rubik's Cube Solver</h1>
    </header>
    <h2>This is solver for Rubik's cube cross, XCross, XXCross, XXXCross, XXXXCross, free pair, last layer(OLL,
        ZBLS, ZBLL). Pseudo XCross and free pair solver also available. EOCross and XEOCross
        solver also available.</h2>
    <a href="https://github.com/or18/RubiksSolverDemo" rel="noopener noreferrer"
        style="white-space: nowrap;">Source</a><a>&nbsp;</a>
    <a href="https://or18.github.io/Rubiks-cube-xcross-solver/" rel="noopener noreferrer"
        style="white-space: nowrap;">Old Demo</a>
    <a href="https://or18.github.io/RubiksSolverDemo/2x2x2" rel="noopener noreferrer" style="white-space: nowrap;">2x2x2
        Solver</a><br><br>
    <a>Trainers:</a><br>
    <a href="https://or18.github.io/RubiksSolverDemo/cross_trainer" rel="noopener noreferrer"
        style="white-space: nowrap;">Cross</a><a>&nbsp;</a>
    <a href="https://or18.github.io/RubiksSolverDemo/xcross_trainer" rel="noopener noreferrer"
        style="white-space: nowrap;">XCross</a><a>&nbsp;</a>
    <a href="https://or18.github.io/RubiksSolverDemo/pairing_trainer" rel="noopener noreferrer"
        style="white-space: nowrap;">Free Pair</a><a>&nbsp;</a>
    <a href="https://or18.github.io/RubiksSolverDemo/pseudo_xcross_trainer" rel="noopener noreferrer"
        style="white-space: nowrap;">Pseudo XCross</a><a>&nbsp;</a>
    <a href="https://or18.github.io/RubiksSolverDemo/pseudo_pairing_trainer" rel="noopener noreferrer"
        style="white-space: nowrap;">Pseudo Free Pair</a><a>&nbsp;</a>
    <a href="https://or18.github.io/RubiksSolverDemo/eocross_trainer" rel="noopener noreferrer"
        style="white-space: nowrap;">EOCross</a><br><br>
    <label for="solver">Solver: </label><br>
    <select translate="no" id="solver" onchange="change(); updateUrlParams();">
        <option translate="no" value="F2L" selected>F2L Lite</option>
        <option translate="no" value="F2L_pair">Pairing</option>
        <option translate="no" value="PF2L">Pseudo F2L Lite</option>
        <option translate="no" value="PF2L_pair">Pseudo Pairing</option>
        <option translate="no" value="EOCross">EOCross</option>
        <option translate="no" value="LS">LL Substeps Lite</option>
        <option translate="no" value="LL">LL Lite</option>
        <option translate="no" value="LU">LL AUF Lite</option>
        <option translate="no" value="twophase">Two Phase</option>
        <option translate="no" value="F2L2">F2L</option>
        <option translate="no" value="LS2">LL Substeps</option>
        <option translate="no" value="LL2">LL</option>
        <option translate="no" value="LU2">LL AUF</option>
    </select>
    <button id="undo" class="button small hidden_small" onclick="undo()">←</button>
    <button id="redo" class="button small hidden_small" onclick="redo()">→</button><br>
    <label for="scr">Scramble: </label><br>
    <textarea id="scr" rows="10" cols="10" placeholder="Use // to write comments, as in algs // comment. 
Write the //setup comment in the appropriate position when viewing on alg.cubing.net or cubedb.net."
        onchange="save()"></textarea><br>
    <button id="gen" class="button medium" onclick="genscr()">Random</button>
    <button id="reverse" class="button medium" onclick="reverseScramble()">Reverse</button>
    <button id="mirror" class="button medium" onclick="mirrorScramble()">Mirror</button><br><br>
    <details id="details_preview">
        <summary id="summary_preview">Show Preview</summary>
        <div id="show"></div>
        <pre id="links"
            class="hidden"><a translate="no" id="link_alg_cubing" href="https://alg.cubing.net/" target="_blank" rel="noopener noreferrer">alg.cubing.net</a>  <a translate="no" id="link_cubedb" href="https://cubedb.net/?puzzle=3x3" target="_blank" rel="noopener noreferrer">cubedb.net</a></pre>
    </details>
    <details id="analyze">
        <summary id="summary_analyzer">Show Analyzer</summary><br>
        <label for="analyzer_rotation_option">Face Option: </label>
        <fieldset id="analyzer_rotation_option">
            <input type="checkbox" id="checkboxD_analyzer" class="custom-checkbox analyzer" value="D" checked>
            <label translate="no" for="checkboxD_analyzer">D</label>
            <input type="checkbox" id="checkboxU_analyzer" class="custom-checkbox analyzer" value="U">
            <label translate="no" for="checkboxU_analyzer">U</label>
            <input type="checkbox" id="checkboxL_analyzer" class="custom-checkbox analyzer" value="L">
            <label translate="no" for="checkboxL_analyzer">L</label>
            <input type="checkbox" id="checkboxR_analyzer" class="custom-checkbox analyzer" value="R">
            <label translate="no" for="checkboxR_analyzer">R</label>
            <input type="checkbox" id="checkboxF_analyzer" class="custom-checkbox analyzer" value="F">
            <label translate="no" for="checkboxF_analyzer">F</label>
            <input type="checkbox" id="checkboxB_analyzer" class="custom-checkbox analyzer" value="B">
            <label translate="no" for="checkboxB_analyzer">B</label>
        </fieldset>
        <label for="analyzer_option">Solver Option: </label>
        <select translate="no" id="analyzer_option">
            <option translate="no" value="cross">cross</option>
            <option translate="no" value="xcross">xcross</option>
            <option translate="no" value="xxcross">xxcross</option>
            <option translate="no" value="xxxcross">xxxcross</option>
            <option translate="no" value="2x">cross, x</option>
            <option translate="no" value="3x">cross, x, xx</option>
            <option translate="no" value="4x">cross, x, xx, xxx</option>
        </select><br>
        <label for="analyzer_num">Count: </label>
        <input type="number" id="analyzer_num" value="1" min="1" required><br>
        <button id="analyzer" class="button medium" onclick="analyze()">Analyze</button><br>
        <div id="table"></div>
    </details>

    <details id="eo_analyze">
        <summary id="summary_eo_analyzer">Show Analyzer</summary><br>
        <label for="eo_analyzer_rotation_option">Face Option: </label>
        <fieldset id="eo_analyzer_rotation_option">
            <input type="checkbox" id="checkboxD_eo_analyzer" class="custom-checkbox eo_analyzer" value="D" checked>
            <label translate="no" for="checkboxD_eo_analyzer">D</label>
            <input type="checkbox" id="checkboxU_eo_analyzer" class="custom-checkbox eo_analyzer" value="U">
            <label translate="no" for="checkboxU_eo_analyzer">U</label>
            <input type="checkbox" id="checkboxL_eo_analyzer" class="custom-checkbox eo_analyzer" value="L">
            <label translate="no" for="checkboxL_eo_analyzer">L</label>
            <input type="checkbox" id="checkboxR_eo_analyzer" class="custom-checkbox eo_analyzer" value="R">
            <label translate="no" for="checkboxR_eo_analyzer">R</label>
            <input type="checkbox" id="checkboxF_eo_analyzer" class="custom-checkbox eo_analyzer" value="F">
            <label translate="no" for="checkboxF_eo_analyzer">F</label>
            <input type="checkbox" id="checkboxB_eo_analyzer" class="custom-checkbox eo_analyzer" value="B">
            <label translate="no" for="checkboxB_eo_analyzer">B</label>
        </fieldset>
        <label for="eo_analyzer_option">Solver Option: </label>
        <select translate="no" id="eo_analyzer_option">
            <option translate="no" value="cross">cross</option>
            <option translate="no" value="xcross">xcross</option>
            <option translate="no" value="xxcross">xxcross</option>
            <option translate="no" value="xxxcross">xxxcross</option>
            <option translate="no" value="2x">cross, x</option>
            <option translate="no" value="3x">cross, x, xx</option>
            <option translate="no" value="4x">cross, x, xx, xxx</option>
        </select><br>
        <label for="eo_analyzer_num">Count: </label>
        <input type="number" id="eo_analyzer_num" value="1" min="1" required><br>
        <button id="eo_analyzer" class="button medium" onclick="eo_analyze()">Analyze</button>
        <div id="eo_table"></div>
    </details>

    <details id="panalyze">
        <summary id="summary_panalyzer">Show Analyzer</summary><br>
        <label for="panalyzer_rotation_option">Face Option: </label>
        <fieldset id="panalyzer_rotation_option">
            <input type="checkbox" id="checkboxD_panalyzer" class="custom-checkbox panalyzer" value="D" checked>
            <label translate="no" for="checkboxD_panalyzer">D</label>
            <input type="checkbox" id="checkboxU_panalyzer" class="custom-checkbox panalyzer" value="U">
            <label translate="no" for="checkboxU_panalyzer">U</label>
            <input type="checkbox" id="checkboxL_panalyzer" class="custom-checkbox panalyzer" value="L">
            <label translate="no" for="checkboxL_panalyzer">L</label>
            <input type="checkbox" id="checkboxR_panalyzer" class="custom-checkbox panalyzer" value="R">
            <label translate="no" for="checkboxR_panalyzer">R</label>
            <input type="checkbox" id="checkboxF_panalyzer" class="custom-checkbox panalyzer" value="F">
            <label translate="no" for="checkboxF_panalyzer">F</label>
            <input type="checkbox" id="checkboxB_panalyzer" class="custom-checkbox panalyzer" value="B">
            <label translate="no" for="checkboxB_panalyzer">B</label>
        </fieldset>
        <label for="panalyzer_option">Solver Option: </label>
        <select translate="no" id="panalyzer_option">
            <option translate="no" value="cross">cross</option>
            <option translate="no" value="xcross">xcross</option>
            <option translate="no" value="xxcross">xxcross</option>
            <option translate="no" value="xxxcross">xxxcross</option>
            <option translate="no" value="2x">cross, x</option>
            <option translate="no" value="3x">cross, x, xx</option>
            <option translate="no" value="4x">cross, x, xx, xxx</option>
        </select><br>
        <label for="panalyzer_num">Count: </label>
        <input type="number" id="panalyzer_num" value="1" min="1" required><br>
        <button id="panalyzer" class="button medium" onclick="panalyze()">Analyze</button>
        <div id="ptable"></div>
    </details>

    <details id="pair_analyze">
        <summary id="summary_pair_analyzer">Show Analyzer</summary><br>
        <label for="pair_analyzer_rotation_option">Face Option: </label>
        <fieldset id="pair_analyzer_rotation_option">
            <input type="checkbox" id="checkboxD_pair_analyzer" class="custom-checkbox pair_analyzer" value="D" checked>
            <label translate="no" for="checkboxD_pair_analyzer">D</label>
            <input type="checkbox" id="checkboxU_pair_analyzer" class="custom-checkbox pair_analyzer" value="U">
            <label translate="no" for="checkboxU_pair_analyzer">U</label>
            <input type="checkbox" id="checkboxL_pair_analyzer" class="custom-checkbox pair_analyzer" value="L">
            <label translate="no" for="checkboxL_pair_analyzer">L</label>
            <input type="checkbox" id="checkboxR_pair_analyzer" class="custom-checkbox pair_analyzer" value="R">
            <label translate="no" for="checkboxR_pair_analyzer">R</label>
            <input type="checkbox" id="checkboxF_pair_analyzer" class="custom-checkbox pair_analyzer" value="F">
            <label translate="no" for="checkboxF_pair_analyzer">F</label>
            <input type="checkbox" id="checkboxB_pair_analyzer" class="custom-checkbox pair_analyzer" value="B">
            <label translate="no" for="checkboxB_pair_analyzer">B</label>
        </fieldset>
        <label for="pair_analyzer_option">Solver Option: </label>
        <select translate="no" id="pair_analyzer_option">
            <option translate="no" value="cross">cross</option>
            <option translate="no" value="xcross">xcross</option>
            <option translate="no" value="xxcross">xxcross</option>
            <option translate="no" value="xxxcross">xxxcross</option>
            <option translate="no" value="2x">cross, x</option>
            <option translate="no" value="3x">cross, x, xx</option>
            <option translate="no" value="4x">cross, x, xx, xxx</option>
        </select><br>
        <label for="pair_analyzer_num">Count: </label>
        <input type="number" id="pair_analyzer_num" value="1" min="1" required><br>
        <button id="pair_analyzer" class="button medium" onclick="pair_analyze()">Analyze</button>
        <div id="pair_table"></div>
    </details>

    <details id="pair_panalyze">
        <summary id="summary_pair_panalyzer">Show Analyzer</summary><br>
        <label for="pair_panalyzer_rotation_option">Face Option: </label>
        <fieldset id="pair_panalyzer_rotation_option">
            <input type="checkbox" id="checkboxD_pair_panalyzer" class="custom-checkbox pair_panalyzer" value="D"
                checked>
            <label translate="no" for="checkboxD_pair_panalyzer">D</label>
            <input type="checkbox" id="checkboxU_pair_panalyzer" class="custom-checkbox pair_panalyzer" value="U">
            <label translate="no" for="checkboxU_pair_panalyzer">U</label>
            <input type="checkbox" id="checkboxL_pair_panalyzer" class="custom-checkbox pair_panalyzer" value="L">
            <label translate="no" for="checkboxL_pair_panalyzer">L</label>
            <input type="checkbox" id="checkboxR_pair_panalyzer" class="custom-checkbox pair_panalyzer" value="R">
            <label translate="no" for="checkboxR_pair_panalyzer">R</label>
            <input type="checkbox" id="checkboxF_pair_panalyzer" class="custom-checkbox pair_panalyzer" value="F">
            <label translate="no" for="checkboxF_pair_panalyzer">F</label>
            <input type="checkbox" id="checkboxB_pair_panalyzer" class="custom-checkbox pair_panalyzer" value="B">
            <label translate="no" for="checkboxB_pair_panalyzer">B</label>
        </fieldset>
        <label for="pair_panalyzer_option">Solver Option: </label>
        <select translate="no" id="pair_panalyzer_option">
            <option translate="no" value="cross">cross</option>
            <option translate="no" value="xcross">xcross</option>
            <option translate="no" value="xxcross">xxcross</option>
            <option translate="no" value="xxxcross">xxxcross</option>
            <option translate="no" value="2x">cross, x</option>
            <option translate="no" value="3x">cross, x, xx</option>
            <option translate="no" value="4x">cross, x, xx, xxx</option>
        </select><br>
        <label for="pair_panalyzer_num">Count: </label>
        <input type="number" id="pair_panalyzer_num" value="1" min="1" required><br>
        <button id="pair_panalyzer" class="button medium" onclick="pair_panalyze()">Analyze</button>
        <div id="pair_ptable"></div>
    </details><br>

    <label for="rot">Rotation: </label>
    <select translate="no" id="rot" onchange="updateUrlParams()">
        <option translate="no" value="">None</option>
        <option translate="no" value="y">y</option>
        <option translate="no" value="y2">y2</option>
        <option translate="no" value="y'">y'</option>
        <option translate="no" value="z2">z2</option>
        <option translate="no" value="z2 y">z2 y</option>
        <option translate="no" value="z2 y2">z2 y2</option>
        <option translate="no" value="z2 y'">z2 y'</option>
        <option translate="no" value="z'">z'</option>
        <option translate="no" value="z' y">z' y</option>
        <option translate="no" value="z' y2">z' y2</option>
        <option translate="no" value="z' y'">z' y'</option>
        <option translate="no" value="z">z</option>
        <option translate="no" value="z y">z y</option>
        <option translate="no" value="z y2">z y2</option>
        <option translate="no" value="z y'">z y'</option>
        <option translate="no" value="x'">x'</option>
        <option translate="no" value="x' y">x' y</option>
        <option translate="no" value="x' y2">x' y2</option>
        <option translate="no" value="x' y'">x' y'</option>
        <option translate="no" value="x2">x2</option>
        <option translate="no" value="x2 y">x2 y</option>
        <option translate="no" value="x2 y2">x2 y2</option>
        <option translate="no" value="x2 y'">x2 y'</option>
        <option translate="no" value="x">x</option>
        <option translate="no" value="x y">x y</option>
        <option translate="no" value="x y2">x y2</option>
        <option translate="no" value="x y'">x y'</option>
    </select><br>
    <div id="option_for_F2L" class="hidden">
        <label for="slot">Slot: </label>
        <select translate="no" id="slot" onchange="updateUrlParams()">
            <option translate="no" value="">None</option>
            <option translate="no" value="BL">BL</option>
            <option translate="no" value="BR">BR</option>
            <option translate="no" value="FR">FR</option>
            <option translate="no" value="FL">FL</option>
            <option translate="no" value="BL BR">BL BR</option>
            <option translate="no" value="BL FR">BL FR</option>
            <option translate="no" value="BL FL">BL FL</option>
            <option translate="no" value="BR FR">BR FR</option>
            <option translate="no" value="BR FL">BR FL</option>
            <option translate="no" value="FR FL">FR FL</option>
            <option translate="no" value="BL BR FR">BL BR FR</option>
            <option translate="no" value="BL BR FL">BL BR FL</option>
            <option translate="no" value="BL FR FL">BL FR FL</option>
            <option translate="no" value="BR FR FL">BR FR FL</option>
            <option translate="no" value="BL BR FR FL">BL BR FR FL</option>
        </select>
    </div>
    <div id="option_for_PF2L" class="hidden">
        <div id="option_for_PF2LE">
            <label for="pslot_edge">Pseudo Slot Edge: </label>
            <select translate="no" id="pslot_edge" onchange="updateDropdown(); updateUrlParams();">
                <option translate="no" value="">None</option>
                <option translate="no" value="BL">BL</option>
                <option translate="no" value="BR">BR</option>
                <option translate="no" value="FR">FR</option>
                <option translate="no" value="FL">FL</option>
                <option translate="no" value="BL BR">BL BR</option>
                <option translate="no" value="BL FR">BL FR</option>
                <option translate="no" value="BL FL">BL FL</option>
                <option translate="no" value="BR FR">BR FR</option>
                <option translate="no" value="BR FL">BR FL</option>
                <option translate="no" value="FR FL">FR FL</option>
                <option translate="no" value="BL BR FR">BL BR FR</option>
                <option translate="no" value="BL BR FL">BL BR FL</option>
                <option translate="no" value="BL FR FL">BL FR FL</option>
                <option translate="no" value="BR FR FL">BR FR FL</option>
            </select>
        </div>
        <div id="option_for_PF2LC" class="hidden">
            <label for="pslot_corner">Pseudo Slot Corner: </label>
            <select translate="no" id="pslot_corner" onchange="updateUrlParams()">
            </select>
        </div>
    </div>

    <div id="option_for_F2L2" class="hidden">
        <label for="slot2">Slot: </label>
        <select translate="no" id="slot2" onchange="updateDropdown2(); updateUrlParams()">
            <option translate="no" value="">None</option>
            <option translate="no" value="BL">BL</option>
            <option translate="no" value="BR">BR</option>
            <option translate="no" value="FR">FR</option>
            <option translate="no" value="FL">FL</option>
            <option translate="no" value="BL BR">BL BR</option>
            <option translate="no" value="BL FR">BL FR</option>
            <option translate="no" value="BL FL">BL FL</option>
            <option translate="no" value="BR FR">BR FR</option>
            <option translate="no" value="BR FL">BR FL</option>
            <option translate="no" value="FR FL">FR FL</option>
            <option translate="no" value="BL BR FR">BL BR FR</option>
            <option translate="no" value="BL BR FL">BL BR FL</option>
            <option translate="no" value="BL FR FL">BL FR FL</option>
            <option translate="no" value="BR FR FL">BR FR FL</option>
        </select>
    </div>
    <div id="option_for_pair_F2L" class="hidden">
        <label for="pair_slot">Free Pair: </label>
        <select translate="no" id="pair_slot" onchange="updateUrlParams()">
            <option translate="no" value="BL">BL</option>
            <option translate="no" value="BR">BR</option>
            <option translate="no" value="FR">FR</option>
            <option translate="no" value="FL">FL</option>
        </select>
    </div>
    <div id="option_for_PF2L2" class="hidden">
        <div id="option_for_PF2LE2">
            <label for="pslot_edge2">Pseudo Slot Edge: </label>
            <select translate="no" id="pslot_edge2" onchange="updateDropdown3(); updateUrlParams()">
                <option translate="no" value="">None</option>
                <option translate="no" value="BL">BL</option>
                <option translate="no" value="BR">BR</option>
                <option translate="no" value="FR">FR</option>
                <option translate="no" value="FL">FL</option>
                <option translate="no" value="BL BR">BL BR</option>
                <option translate="no" value="BL FR">BL FR</option>
                <option translate="no" value="BL FL">BL FL</option>
                <option translate="no" value="BR FR">BR FR</option>
                <option translate="no" value="BR FL">BR FL</option>
                <option translate="no" value="FR FL">FR FL</option>
                <option translate="no" value="BL BR FR">BL BR FR</option>
                <option translate="no" value="BL BR FL">BL BR FL</option>
                <option translate="no" value="BL FR FL">BL FR FL</option>
                <option translate="no" value="BR FR FL">BR FR FL</option>
            </select>
        </div>
        <div id="option_for_PF2LC2" class="hidden">
            <label for="pslot_corner2">Pseudo Slot Corner: </label>
            <select translate="no" id="pslot_corner2" onchange="updateDropdown4(); updateUrlParams()">
            </select>
        </div>
        <div id="option_for_pair_PF2L" class="hidden">
            <div id="option_for_pair_PF2LE">
                <label for="pair_pslot_edge">Free Pair Edge: </label>
                <select translate="no" id="pair_pslot_edge" onchange="updateUrlParams()">
                    <option translate="no" value="BL">BL</option>
                    <option translate="no" value="BR">BR</option>
                    <option translate="no" value="FR">FR</option>
                    <option translate="no" value="FL">FL</option>
                </select>
            </div>
            <div id="option_for_pair_PF2LC">
                <label for="pair_pslot_corner">Free Pair Corner: </label>
                <select translate="no" id="pair_pslot_corner" onchange="updateUrlParams()">
                    <option translate="no" value="BL">BL</option>
                    <option translate="no" value="BR">BR</option>
                    <option translate="no" value="FR">FR</option>
                    <option translate="no" value="FL">FL</option>
                </select>
            </div>
        </div>
    </div>
    <div id="option_for_eocross" class="hidden">
        <label for="slot_eo">Slot: </label>
        <select translate="no" id="slot_eo" onchange="updateUrlParams()">
            <option translate="no" value="">None</option>
            <option translate="no" value="BL">BL</option>
            <option translate="no" value="BR">BR</option>
            <option translate="no" value="FR">FR</option>
            <option translate="no" value="FL">FL</option>
            <option translate="no" value="BL BR">BL BR</option>
            <option translate="no" value="BL FR">BL FR</option>
            <option translate="no" value="BL FL">BL FL</option>
            <option translate="no" value="BR FR">BR FR</option>
            <option translate="no" value="BR FL">BR FL</option>
            <option translate="no" value="FR FL">FR FL</option>
            <option translate="no" value="BL BR FR">BL BR FR</option>
            <option translate="no" value="BL BR FL">BL BR FL</option>
            <option translate="no" value="BL FR FL">BL FR FL</option>
            <option translate="no" value="BR FR FL">BR FR FL</option>
            <option translate="no" value="BL BR FR FL">BL BR FR FL</option>
        </select>
    </div>

    <div id="option_for_LS" class="hidden">
        <label for="ll">Last Layer Option: </label>
        <select translate="no" id="ll" onchange="updateUrlParams()">
            <option translate="no" value="">None</option>
            <option translate="no" value="CP">CP</option>
            <option translate="no" value="CO">CO</option>
            <option translate="no" value="EP">EP</option>
            <option translate="no" value="EO">EO</option>
            <option translate="no" value="CP CO">CP CO</option>
            <option translate="no" value="CP EP">CP EP</option>
            <option translate="no" value="CP EO">CP EO</option>
            <option translate="no" value="CO EP">CO EP</option>
            <option translate="no" value="CO EO">CO EO</option>
            <option translate="no" value="EP EO">EP EO</option>
            <option translate="no" value="CP CO EP">CP CO EP</option>
            <option translate="no" value="CP CO EO">CP CO EO</option>
            <option translate="no" value="CP EO EP">CP EO EP</option>
            <option translate="no" value="CO EP EO">CO EP EO</option>
            <option translate="no" value="CP CO EP EO">CP CO EP EO</option>
        </select>
    </div>
    <div id="basic input">
        <label for="len">Max Length: </label>
        <input type="number" id="len" value="20" min="1" required onchange="updateUrlParams()"><br>
        <label for="num">Max Count: </label>
        <input type="number" id="num" value="20" min=1 required onchange="updateUrlParams()"><br>
        <label for="res">Move Restrict: </label>
        <fieldset translate="no" id="res" onchange="updateUrlParams()">
            <input type="checkbox" id="checkboxU_restrict" class="custom-checkbox restrict" value="U" checked>
            <label translate="no" for="checkboxU_restrict">U</label>
            <input type="checkbox" id="checkboxD_restrict" class="custom-checkbox restrict" value="D" checked>
            <label translate="no" for="checkboxD_restrict">D</label>
            <input type="checkbox" id="checkboxL_restrict" class="custom-checkbox restrict" value="L" checked>
            <label translate="no" for="checkboxL_restrict">L</label>
            <input type="checkbox" id="checkboxR_restrict" class="custom-checkbox restrict" value="R" checked>
            <label translate="no" for="checkboxR_restrict">R</label>
            <input type="checkbox" id="checkboxF_restrict" class="custom-checkbox restrict" value="F" checked>
            <label translate="no" for="checkboxF_restrict">F</label>
            <input type="checkbox" id="checkboxB_restrict" class="custom-checkbox restrict" value="B" checked>
            <label translate="no" for="checkboxB_restrict">B</label><br><br>
            <input type="checkbox" id="checkboxu_restrict" class="custom-checkbox restrict" value="u">
            <label translate="no" for="checkboxu_restrict">u</label>
            <input type="checkbox" id="checkboxd_restrict" class="custom-checkbox restrict" value="d">
            <label translate="no" for="checkboxd_restrict">d</label>
            <input type="checkbox" id="checkboxl_restrict" class="custom-checkbox restrict" value="l">
            <label translate="no" for="checkboxl_restrict">l</label>
            <input type="checkbox" id="checkboxr_restrict" class="custom-checkbox restrict" value="r">
            <label translate="no" for="checkboxr_restrict">r</label>
            <input type="checkbox" id="checkboxf_restrict" class="custom-checkbox restrict" value="f">
            <label translate="no" for="checkboxf_restrict">f</label>
            <input type="checkbox" id="checkboxb_restrict" class="custom-checkbox restrict" value="b">
            <label translate="no" for="checkboxb_restrict">b</label><br><br>
            <input type="checkbox" id="checkboxM_restrict" class="custom-checkbox restrict" value="M">
            <label translate="no" for="checkboxM_restrict">M</label>
            <input type="checkbox" id="checkboxE_restrict" class="custom-checkbox restrict" value="E">
            <label translate="no" for="checkboxE_restrict">E</label>
            <input type="checkbox" id="checkboxS_restrict" class="custom-checkbox restrict" value="S">
            <label translate="no" for="checkboxS_restrict">S</label>
            <input type="checkbox" id="checkboxx_restrict" class="custom-checkbox restrict" value="x">
            <label translate="no" for="checkboxx_restrict">x</label>
            <input type="checkbox" id="checkboxy_restrict" class="custom-checkbox restrict" value="y">
            <label translate="no" for="checkboxy_restrict">y</label>
            <input type="checkbox" id="checkboxz_restrict" class="custom-checkbox restrict" value="z">
            <label translate="no" for="checkboxz_restrict">z</label>
        </fieldset><br>

        <details id="advancedSettings">
            <summary id="summaryAdvancedSettings">Show Advanced Settings</summary>
            <label for="premove">Pre Move: </label>
            <input type="text" id="premove" onchange="updateUrlParams()"><br>
            <label for="res_table">Move Restrict:</label>
            <div id="res_table_wrapper" onchange="updateUrlParams()">
                <table id="res_table" border="2" translate="no">
                    <thead>
                        <tr>
                            <th></th>
                            <th>* </th>
                            <th>* 2 </th>
                            <th>* ' </th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div><br>
            <label for="move_available_table">Move Available Table:</label>
            <div id="move_available_table_wrapper" onchange="updateUrlParams()">
                <table id="move_available_table" border="2" translate="no">
                    <thead></thead>
                    <tbody></tbody>
                </table>
            </div><br>
            <label for="center_restrict">Center Restrict:</label>
            <div id="center_restrict_wrapper" onchange="updateUrlParams()">
                <table id="center_restrict" border="2" translate="no">
                    <thead>
                        <tr>
                            <th></th>
                            <th>* </th>
                            <th>* y</th>
                            <th>* y2</th>
                            <th>* y'</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th> </th>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_EMPTY_EMPTY"
                                    class="custom-checkbox restrict" checked>
                                <label for="checkbox_center_restrict_EMPTY_EMPTY"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_EMPTY_y"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_EMPTY_y"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_EMPTY_y2"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_EMPTY_y2"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_EMPTY_y-"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_EMPTY_y-"></label>
                            </td>
                        </tr>
                        <tr>
                            <th>z2</th>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z2_EMPTY"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z2_EMPTY"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z2_y"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z2_y"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z2_y2"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z2_y2"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z2_y-"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z2_y-"></label>
                            </td>
                        </tr>
                        <tr>
                            <th>z'</th>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z-_EMPTY"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z-_EMPTY"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z-_y"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z-_y"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z-_y2"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z-_y2"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z-_y-"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z-_y-"></label>
                            </td>
                        </tr>
                        <tr>
                            <th>z</th>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z_EMPTY"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z_EMPTY"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z_y"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z_y"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z_y2"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z_y2"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_z_y-"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_z_y-"></label>
                            </td>
                        </tr>
                        <tr>
                            <th>x'</th>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x-_EMPTY"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x-_EMPTY"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x-_y"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x-_y"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x-_y2"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x-_y2"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x-_y-"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x-_y-"></label>
                            </td>
                        </tr>
                        <tr>
                            <th>x</th>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x_EMPTY"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x_EMPTY"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x_y"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x_y"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x_y2"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x_y2"></label>
                            </td>
                            <td>
                                <input type="checkbox" id="checkbox_center_restrict_x_y-"
                                    class="custom-checkbox restrict">
                                <label for="checkbox_center_restrict_x_y-"></label>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div><br>
            <label for="rotation_count">Max Rotation Count: </label>
            <input type="number" id="rot_count" value=0 min=0 required onchange="updateUrlParams()"><br>
        </details>
        <br>

        <input type="checkbox" id="CheckboxAutoMaskSetting" class="custom-checkbox" checked>
        <label for="CheckboxAutoMaskSetting">Auto Stickering Setting </label>

        <details id="maskOptions">
            <summary id="summaryMaskOptions">Show Stickering Settings</summary>
            <div id="preview"></div>
            <button id="autoSetMask" class="button medium" onclick="setStickeringOptionAuto()">Auto</button>
            <button id="resetMask" class="button medium" onclick="resetStickeringOptions('-')">Reset</button><br><br>
            <div id="maskOptionsCenterDiv">
                <label for="maskOptionCenter">Centers: </label>
                <select id="maskOptionCenter">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="I">Ignored</option>
                </select>
            </div>
            <label for="maskOptionsEdge">Edges Options</label><br>
            <div id="maskOptionsEdge">
                <label for="maskOptionDE">Cross: </label>
                <select id="maskOptionDE">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionBLE">BL Slot: </label>
                <select id="maskOptionBLE">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionBRE">BR Slot: </label>
                <select id="maskOptionBRE">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionFRE">FR Slot: </label>
                <select id="maskOptionFRE">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionFLE">FL Slot: </label>
                <select id="maskOptionFLE">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionLLE">Last Layer: </label>
                <select id="maskOptionLLE">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select>
            </div>
            <label for="maskOptionsCorner">Corners Options</label><br>
            <div id="maskOptionsCorner">
                <label for="maskOptionBLC">BL Slot: </label>
                <select id="maskOptionBLC">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionBRC">BR Slot: </label>
                <select id="maskOptionBRC">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionFRC">FR Slot: </label>
                <select id="maskOptionFRC">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionFLC">FL Slot: </label>
                <select id="maskOptionFLC">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select><br>
                <label for="maskOptionLLC">Last Layer: </label>
                <select id="maskOptionLLC">
                    <option value="-">Regular</option>
                    <option value="D">Dim</option>
                    <option value="?">Oriented</option>
                    <option value="I">Ignored</option>
                </select>
            </div>
        </details>
    </div>
    <a class="hidden" id="tp_alert">Two Phase Solver output 1 solution.<br></a>
    <button id="solveButton" class="button medium" onclick="startWorker()">Start</button><br>
    <label for="countLine">Number of solutions: </label>
    <input type="text" id="countLine" value="0" readonly>
    <div id="result"></div>

    <script type="module">
        import { TwistyPlayer } from "https://cdn.cubing.net/v0/js/cubing/twisty";
        function createPlayer(setup, sol) {
            const player = new TwistyPlayer({
                puzzle: "3x3x3",
                experimentalSetupAlg: setup,
                alg: sol,
                background: "none"
            });
            return player;
        }
        window.createPlayer = createPlayer;
    </script>

    <script>
        Module.onRuntimeInitialized = function () {
            window.reverse = function (scr) {
                const scr_fixed = scr_fix2(scr);
                if (scr_fixed === "") {
                    return;
                }
                const lines = scr_fixed.split('\n');
                const processedLines = [];
                for (let i = lines.length - 1; i >= 0; i--) {
                    const line = lines[i];
                    const [alg, comment] = line.split('//');
                    const alg_revresed = Module.scr_reverse(alg.trim());
                    if (comment) {
                        processedLines.push(`${alg_revresed} // ${comment.trim()}`);
                    } else {
                        processedLines.push(alg_revresed);
                    }
                }
                const result = processedLines.join('\n');
                return result.trim() + "\n";
            };
            window.mirror = function (scr) {
                if (typeof Module.scr_mirror !== "function") {
                    alert("Error: The required function is not initialized. Please reload the page manually.");
                    return;
                }
                const scr_fixed = scr_fix2(scr);
                if (scr_fixed === "") {
                    return;
                }
                const lines = scr_fixed.split('\n');
                const processedLines = [];
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const [alg, comment] = line.split('//');
                    const alg_mirrored = Module.scr_mirror(alg.trim());
                    if (comment) {
                        processedLines.push(`${alg_mirrored} // ${comment.trim()}`);
                    } else {
                        processedLines.push(alg_mirrored);
                    }
                }
                const result = processedLines.join('\n');
                return result.trim() + "\n";
            };
            window.convert = function (scramble) {
                const result = Module.scr_converter(scramble);
                const resultArray = result.split(',');
                return resultArray.map(part => part.trim());
            };
            window.generateTwoPhaseInput = function (scramble) {
                const result = Module.ScrambleToState(scramble);
                return result;
            };
            window.convertMask = function (center_input, edge_input, corner_input, rotation_alg) {
                const result = Module.convertMask(center_input, edge_input, corner_input, rotation_alg);
                return result;
            };
        };
    </script>

    <script>
        let worker;
        let worker2;
        let worker3;
        let worker4;
        let worker5;
        let worker6;
        let messageCount = 0;
        let messageCount_analyzer = 0;
        let messageCount_panalyzer = 0;
        let messageCount_pair_analyzer = 0;
        let messageCount_pair_panalyze = 0;
        let messageCount_eo_analyzer = 0;
        let option_table;
        let option_ptable;
        let option_pair_table;
        let option_pair_ptable;
        let option_eo_table;
        let list_table;
        let list_ptable;
        let list_pair_table;
        let list_pair_ptable;
        let list_eo_table;
        let sol_input = false;
        let AutoMaskSetting = true;
        let mask = {
            orbits: {
                EDGES: {
                    pieces: [
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                        { facelets: ["regular", "regular"] },
                    ],
                },
                CORNERS: {
                    pieces: [
                        { facelets: ["regular", "regular", "regular"] },
                        { facelets: ["regular", "regular", "regular"] },
                        { facelets: ["regular", "regular", "regular"] },
                        { facelets: ["regular", "regular", "regular"] },
                        { facelets: ["regular", "regular", "regular"] },
                        { facelets: ["regular", "regular", "regular"] },
                        { facelets: ["regular", "regular", "regular"] },
                        { facelets: ["regular", "regular", "regular"] },
                    ],
                },
                CENTERS: {
                    pieces: [
                        { facelets: ["regular"] },
                        { facelets: ["regular"] },
                        { facelets: ["regular"] },
                        { facelets: ["regular"] },
                        { facelets: ["regular"] },
                        { facelets: ["regular"] },
                    ],
                },
            },
        };
        let tmp_mask = mask;

        function getMaskInputs() {
            const maskInputCenter = document.getElementById("maskOptionCenter").value;
            const selectsEdges = document.querySelectorAll('#maskOptionsEdge select');
            const selectsCorners = document.querySelectorAll('#maskOptionsCorner select');
            const selectedValuesEdges = [];
            const selectedValuesCorners = [];
            selectsEdges.forEach(select => {
                selectedValuesEdges.push(select.value);
            });
            selectsCorners.forEach(select => {
                selectedValuesCorners.push(select.value);
            });
            const maskInputEdges = selectedValuesEdges.join('');
            const maskInputCorners = selectedValuesCorners.join('');
            return { maskInputCenter, maskInputEdges, maskInputCorners };
        }

        function resetStickeringOptions(option) {
            const selectAll = document.querySelectorAll('#maskOptions select');
            selectAll.forEach(select => {
                select.value = option;
            });
            setMaskTmp();
        }

        function setStickeringOptionsAutoF2LEdges(slot_edges, option) {
            if (slot_edges !== '') {
                const selectsEdges = slot_edges.split(' ');
                const fixedSelectsEdges = selectsEdges.map(select => 'maskOption' + select + 'E');
                fixedSelectsEdges.forEach(select => {
                    const selectElement = document.querySelector(`#maskOptionsEdge select[id*="${select}"]`);
                    if (selectElement) {
                        selectElement.value = option;
                    }
                });
            }
        }

        function setStickeringOptionsAutoF2LCorners(slot_corners, option) {
            if (slot_corners !== '') {
                const selectsCorners = slot_corners.split(' ');
                const fixedSelectsCorners = selectsCorners.map(select => 'maskOption' + select + 'C');
                fixedSelectsCorners.forEach(select => {
                    const selectElement = document.querySelector(`#maskOptionsCorner select[id*="${select}"]`);
                    if (selectElement) {
                        selectElement.value = option;
                    }
                });
            }
        }

        function setStickeringOptionsAutoEO(option) {
            document.getElementById("maskOptionLLE").value = '?';
            setStickeringOptionsAutoF2LEdges('BL BR FR FL', '?');
        }

        function setStickeringOptionAutoLL(ll) {
            resetStickeringOptions('D');
            document.getElementById("maskOptionLLE").value = 'I';
            document.getElementById("maskOptionLLC").value = 'I';
            if (ll !== '') {
                const option_array = ll.split(' ');
                option_array.forEach(option => {
                    switch (option) {
                        case 'CO':
                            document.getElementById("maskOptionLLC").value = '?';
                            break;
                        case 'CP':
                            document.getElementById("maskOptionLLC").value = '-';
                            break;
                        case 'EO':
                            document.getElementById("maskOptionLLE").value = '?';
                            break;
                        case 'EP':
                            document.getElementById("maskOptionLLE").value = '-';
                            break;
                    }
                });
            }
        }

        function setStickeringOptionAuto() {
            const solver = document.getElementById("solver").value;
            var slot, pslote, pslotc, ll;
            switch (solver) {
                case "F2L":
                    resetStickeringOptions('I');
                    document.getElementById("maskOptionCenter").value = '-';
                    document.getElementById("maskOptionDE").value = '-';
                    slot = document.getElementById("slot").value;
                    setStickeringOptionsAutoF2LEdges(slot, '-');
                    setStickeringOptionsAutoF2LCorners(slot, '-');
                    setMaskTmp();
                    break;
                case "F2L2":
                    resetStickeringOptions('I');
                    document.getElementById("maskOptionCenter").value = '-';
                    document.getElementById("maskOptionDE").value = '-';
                    slot = document.getElementById("slot").value;
                    setStickeringOptionsAutoF2LEdges(slot, '-');
                    setStickeringOptionsAutoF2LCorners(slot, '-');
                    setMaskTmp();
                    break;
                case "F2L_pair":
                    resetStickeringOptions('I');
                    document.getElementById("maskOptionCenter").value = '-';
                    document.getElementById('maskOptionDE').value = '-';
                    slot = document.getElementById("slot2").value + ' ' + document.getElementById("pair_slot").value;
                    setStickeringOptionsAutoF2LEdges(slot, '-');
                    setStickeringOptionsAutoF2LCorners(slot, '-');
                    setMaskTmp();
                    break;
                case "PF2L":
                    resetStickeringOptions('I');
                    document.getElementById("maskOptionCenter").value = '-';
                    document.getElementById('maskOptionDE').value = '-';
                    pslote = document.getElementById("pslot_edge").value;
                    pslotc = document.getElementById("pslot_corner").value;
                    setStickeringOptionsAutoF2LEdges(pslote, '-');
                    setStickeringOptionsAutoF2LCorners(pslotc, '-');
                    setMaskTmp();
                    break;
                case "PF2L_pair":
                    resetStickeringOptions('I');
                    document.getElementById("maskOptionCenter").value = '-';
                    document.getElementById('maskOptionDE').value = '-';
                    pslote = document.getElementById("pslot_edge2").value + ' ' + document.getElementById("pair_pslot_edge").value;
                    pslotc = document.getElementById("pslot_corner2").value + ' ' + document.getElementById("pair_pslot_corner").value;
                    setStickeringOptionsAutoF2LEdges(pslote, '-');
                    setStickeringOptionsAutoF2LCorners(pslotc, '-');
                    setMaskTmp();
                    break;
                case "EOCross":
                    resetStickeringOptions('I');
                    document.getElementById("maskOptionCenter").value = '-';
                    setStickeringOptionsAutoEO('?');
                    document.getElementById('maskOptionDE').value = '-';
                    slot = document.getElementById("slot_eo").value;
                    setStickeringOptionsAutoF2LEdges(slot, '-');
                    setStickeringOptionsAutoF2LCorners(slot, '-');
                    setMaskTmp();
                    break;
                case "LS":
                case "LS2":
                    ll = document.getElementById("ll").value;
                    setStickeringOptionAutoLL(ll);
                    setMaskTmp();
                    break;
                case "LL":
                case "LL2":
                case "LU":
                case "LU2":
                    setStickeringOptionAutoLL('CP EP');
                    setMaskTmp();
                    break;
                case "twophase":
                    resetStickeringOptions('-');
                    break;
            }
        }

        function mapFacelet(char) {
            switch (char) {
                case '-':
                    return 'regular';
                case 'D':
                    return 'dim';
                case 'I':
                    return 'ignored';
                case '?':
                    return 'oriented';
            }
        }

        function setMask(inputString, setTmp = false) {
            const edgesString = inputString.slice(0, 24);
            const cornersString = inputString.slice(24, 48);
            const centersString = inputString.slice(48, 54);
            const edges = [];
            for (let i = 0; i < edgesString.length; i += 2) {
                edges.push({ facelets: [mapFacelet(edgesString[i]), mapFacelet(edgesString[i + 1])] });
            }
            const corners = [];
            for (let i = 0; i < cornersString.length; i += 3) {
                corners.push({ facelets: [mapFacelet(cornersString[i]), mapFacelet(cornersString[i + 1]), mapFacelet(cornersString[i + 2])] });
            }
            const centers = [];
            for (let i = 0; i < centersString.length; i++) {
                centers.push({ facelets: [mapFacelet(centersString[i])] });
            }
            if (setTmp) {
                tmp_mask = {
                    orbits: {
                        EDGES: {
                            pieces: edges,
                        },
                        CORNERS: {
                            pieces: corners,
                        },
                        CENTERS: {
                            pieces: centers,
                        },
                    },
                };
            } else {
                mask = {
                    orbits: {
                        EDGES: {
                            pieces: edges,
                        },
                        CORNERS: {
                            pieces: corners,
                        },
                        CENTERS: {
                            pieces: centers,
                        },
                    },
                };
            }
        }

        function setMaskTmp() {
            if (typeof convertMask !== "function" || typeof convert !== "function") {
                alert("Error: The required function is not initialized. Please reload the page manually.");
                return;
            }
            const rot = document.getElementById('rot').value;
            const scr_val = document.getElementById("scr").value;
            const scr = scr_fix2(scr_val);
            const convertResult = convert(scr);
            const result_rotation = convertResult[1] + " " + rot;
            const mask_input = getMaskInputs();
            const convertedMask = convertMask(mask_input.maskInputCenter, mask_input.maskInputEdges, mask_input.maskInputCorners, result_rotation);
            setMask(convertedMask, true);
            try {
                document.getElementById('preview').innerHTML = '';
                const sim = createPlayer(scr + " " + rot, '');
                sim.controlPanel = "none";
                sim.experimentalStickeringMaskOrbits = tmp_mask;
                document.getElementById('preview').appendChild(sim);
            } catch (e) {
                const content = document.createElement('a');
                content.innerHTML = "Warning: Failed to create TwistyPlayer.<br>";
                document.getElementById('preview').appendChild(content);
            }
        }

        function scr_fix(scr) {
            const fixed_scr = scr_fix2(scr);
            const output = fixed_scr.split('\n')
                .map(line => line.split('//')[0].trim())
                .filter(line => line.length > 0)
                .join('\n');
            return output;
        }

        function scr_fix2(scr) {
            const outputString = scr.split('\n').map(line => {
                const commentIndex = line.indexOf('//');
                if (commentIndex !== -1) {
                    const beforeComment = insertSpaces(line.slice(0, commentIndex));
                    const comment = line.slice(commentIndex);
                    return beforeComment + ' ' + comment.trim();
                } else {
                    return insertSpaces(line);
                }
            }).join('\n');
            return outputString;
        }

        function insertSpaces(input) {
            const keys = ["U", "U2", "U2'", "U'", "D", "D2", "D2'", "D'", "L", "L2", "L2'", "L'", "R", "R2", "R2'", "R'", "F", "F2", "F2'", "F'", "B", "B2", "B2'", "B'", "u", "u2", "u2'", "u'", "d", "d2", "d2'", "d'", "l", "l2", "l2'", "l'", "r", "r2", "r2'", "r'", "f", "f2", "f2'", "f'", "b", "b2", "b2'", "b'", "Uw", "Uw2", "Uw2'", "Uw'", "Dw", "Dw2", "Dw2'", "Dw'", "Lw", "Lw2", "Lw2'", "Lw'", "Rw", "Rw2", "Rw2'", "Rw'", "Fw", "Fw2", "Fw2'", "Fw'", "Bw", "Bw2", "Bw2'", "Bw'", "M", "M2", "M2'", "M'", "S", "S2", "S2'", "S'", "E", "E2", "E2'", "E'", "x", "x2", "x2'", "x'", "y", "y2", "y2'", "y'", "z", "z2", "z2'", "z'"];
            const regex = new RegExp(`(${keys.join('|')})`, 'g');
            return input.replace(regex, ' $1').trim()
                .replace(/\s+/g, ' ');
        }

        function replaceCharacters(input) {
            return input
                .replace(/'/g, '-')
                .replace(/\n/g, '%0A')
                .replace(/\//g, '%2F')
                .replace(/ /g, '_');
        }

        function splitAtLastScramble(input) {
            const scrambleRegex = /\/\/\s*setup/g;
            const index = input.search(scrambleRegex);
            if (index !== -1) {
                const scrambleLineEnd = input.indexOf('\n', index);
                const scrambleLine = input.slice(index, scrambleLineEnd !== -1 ? scrambleLineEnd : undefined).trim();
                const aboveScramble = input.slice(0, scrambleLineEnd !== -1 ? scrambleLineEnd : input.length).trim();
                const belowScramble = input.slice(index + scrambleLine.length).trim();
                return { aboveScramble, belowScramble };
            } else {
                return { aboveScramble: input.trim(), belowScramble: '' };
            }
        }

        function getLink(scr) {
            const fixed_scr = scr_fix2(scr);
            const { aboveScramble, belowScramble } = splitAtLastScramble(fixed_scr);
            const transformedAbove = replaceCharacters(aboveScramble);
            const transformedBelow = replaceCharacters(belowScramble);
            const URL1 = "https://alg.cubing.net/?setup=" + transformedAbove + "&alg=" + transformedBelow + "%0A&puzzle=3x3x3";
            const URL2 = "https://cubedb.net/?puzzle=3x3&scramble=" + transformedAbove + "&alg=" + transformedBelow + "%0A";
            return { URL1, URL2 };
        }

        const idToKeyMap = {
            'solver': 'solver',
            'scr': 'scramble',
            'rot': 'rot',
            'slot': 'slot',
            'slot2': 'slot2',
            'slot_eo': 'slot3',
            'pair_slot': 'aslot',
            'pslot_edge': 'pse',
            'pslot_corner': 'psc',
            'pslot_edge2': 'pse2',
            'pslot_corner2': 'psc2',
            'pair_pslot_edge': 'apse',
            'pair_pslot_corner': 'apsc',
            'll': 'll',
            'len': 'len',
            'num': 'num',
            'res': 'res',
            'rest': 'rest',
            'mav': 'mav',
            'premove': 'premove',
            'rot_count': 'rc',
            'center_restrict': 'crest'
        };

        const defaultValues = {
            'F2L': {
                'solver': 'F2L',
                'scr': '',
                'rot': '',
                'slot': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY'
            },
            'LS': {
                'solver': 'LS',
                'scr': '',
                'rot': '',
                'll': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY'
            },
            'LL': {
                'solver': 'LL',
                'scr': '',
                'rot': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY'
            },
            'LU': {
                'solver': 'LU',
                'scr': '',
                'rot': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY'
            },
            'F2L2': {
                'solver': 'F2L2',
                'scr': '',
                'rot': '',
                'slot': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY'
            },
            'LS2': {
                'solver': 'LS2',
                'scr': '',
                'rot': '',
                'll': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY'
            },
            'LL2': {
                'solver': 'LL2',
                'scr': '',
                'rot': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY'
            },
            'LU2': {
                'solver': 'LU2',
                'scr': '',
                'rot': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY'
            },
            'F2L_pair': {
                'solver': 'F2L_pair',
                'scr': '',
                'rot': '',
                'slot2': '',
                'pair_slot': 'BL',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY'
            },
            'PF2L': {
                'solver': 'PF2L',
                'scr': '',
                'rot': '',
                'pslot_edge': '',
                'pslot_corner': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY'
            },
            'PF2L_pair': {
                'solver': 'PF2L_pair',
                'scr': '',
                'rot': '',
                'pslot_edge2': '',
                'pslot_corner2': '',
                'pair_pslot_edge': 'BL',
                'pair_pslot_corner': 'BL',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY'
            },
            'twophase': {
                'solver': 'twophase',
                'scr': '',
                'rot': ''
            },
            'EOCross': {
                'solver': 'EOCross',
                'scr': '',
                'rot': '',
                'slot_eo': '',
                'len': '20',
                'num': '20',
                'res': 'UDLRFB',
                'rest': 'U_U2_U-_D_D2_D-_L_L2_L-_R_R2_R-_F_F2_F-_B_B2_B-',
                'mav': '',
                'premove': '',
                'rot_count': '0',
                'center_restrict': 'EMPTY_EMPTY'
            }
        };

        const idList = [
            'solver',
            'scr',
            'rot',
            'slot',
            'slot2',
            'slot_eo',
            'pair_slot',
            'pslot_edge',
            'pslot_corner',
            'pslot_edge2',
            'pslot_corner2',
            'pair_pslot_edge',
            'pair_pslot_corner',
            'll',
            'len',
            'num',
            'res',
            'rest',
            'mav',
            'premove',
            'rot_count',
            'center_restrict'
        ];

        function getRestrict() {
            const checkboxes = document.querySelectorAll('#res .restrict');
            const values = [];
            checkboxes.forEach(function (checkbox) {
                if (checkbox.checked) {
                    values.push(checkbox.value);
                }
            });
            const rot_set = values.join('');
            return rot_set
        }

        function setRestrict(rot_string) {
            const allCheckboxes = document.querySelectorAll('#res input[type="checkbox"]');
            allCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            for (let i = 0; i < rot_string.length; i++) {
                const char = rot_string.charAt(i);
                const checkboxId = `checkbox${char}_restrict`;
                const checkbox = document.getElementById(checkboxId);
                if (checkbox) {
                    checkbox.checked = true;
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const restrictFieldset = document.getElementById('res');
            const tableWrapper = document.getElementById('res_table_wrapper');
            const tableBody = document.querySelector('#res_table tbody');
            const moveAvailableTable = document.getElementById('move_available_table');

            const moveDisplayNames = {
                u: "u", d: "d", l: "l", r: "r", f: "f", b: "b", x: "x", y: "y", z: "z"
            };

            function createMoveRow(move) {
                const displayName = moveDisplayNames[move] || move.toUpperCase();
                const newRow = document.createElement('tr');
                newRow.dataset.move = move;
                let rowHTML = `<th>${displayName}</th>`;
                for (let i = 1; i <= 3; i++) {
                    rowHTML += `<td>
                <input type="checkbox" id="checkbox_restrict${move}${i}" class="custom-checkbox restrict" value="${move}" checked>
                <label for="checkbox_restrict${move}${i}"></label>
            </td>`;
                }
                newRow.innerHTML = rowHTML;
                return newRow;
            }

            function updateRestrictTable() {
                const restrictCheckboxes = restrictFieldset.querySelectorAll('input[type="checkbox"]');
                restrictCheckboxes.forEach(checkbox => {
                    const move = checkbox.value;
                    const existingRow = tableBody.querySelector(`tr[data-move="${move}"]`);
                    if (checkbox.checked) {
                        if (!existingRow) {
                            tableBody.appendChild(createMoveRow(move));
                        }
                    } else {
                        if (existingRow) {
                            existingRow.remove();
                        }
                    }
                });
            }

            function getIdsFromCheckboxes() {
                const resChecked = restrictFieldset.querySelectorAll('input[type="checkbox"]:checked');
                const resId = Array.from(resChecked).map(cb => cb.value).join('');

                const restChecked = tableBody.querySelectorAll('input[type="checkbox"]:checked');
                const restId = Array.from(restChecked).map(cb => {
                    const move = cb.value;
                    const suffix = cb.id.slice(-1);
                    if (suffix === '1') return move;
                    if (suffix === '2') return move + '2';
                    if (suffix === '3') return move + '-';
                }).join('_');

                return [resId, restId];
            }

            function setCheckboxesFromIds([resId, restId]) {
                restrictFieldset.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);

                const resMoves = resId.split('');
                resMoves.forEach(move => {
                    const cb = restrictFieldset.querySelector(`input[value="${move}"]`);
                    if (cb) cb.checked = true;
                });

                updateRestrictTable();

                tableBody.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);

                const restMoves = restId.split('_');
                restMoves.forEach(restMove => {
                    if (!restMove) return;

                    const move = restMove.charAt(0);
                    const suffix = restMove.slice(1);
                    let idSuffix;

                    if (suffix === '') idSuffix = '1';
                    else if (suffix === '2') idSuffix = '2';
                    else if (suffix === '-') idSuffix = '3';
                    else return;

                    const cb = tableBody.querySelector(`#checkbox_restrict${move}${idSuffix}`);
                    if (cb) cb.checked = true;
                });
                updateMoveAvailableTable();
            }

            function sanitizeMoveForId(moveStr) {
                if (moveStr === '') return 'EMPTY';
                return moveStr.replace(/'/g, '-');
            }

            function updateMoveAvailableTable() {
                const thead = moveAvailableTable.querySelector('thead');
                const tbody = moveAvailableTable.querySelector('tbody');

                const previousStates = new Map();
                moveAvailableTable.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    previousStates.set(cb.id, cb.checked);
                });

                const restChecked = tableWrapper.querySelectorAll('input[type="checkbox"]:checked');
                const headers = Array.from(restChecked).map(cb => {
                    const move = cb.value;
                    const suffix = cb.id.slice(-1);
                    if (suffix === '1') return move;
                    if (suffix === '2') return move + '2';
                    if (suffix === '3') return move + "'";
                    return '';
                }).filter(Boolean);

                const colHeaders = headers;
                const rowHeaders = [...headers, ""];

                thead.innerHTML = '';
                tbody.innerHTML = '';

                const headerRow = document.createElement('tr');
                headerRow.appendChild(document.createElement('th'));
                colHeaders.forEach(headerText => {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);

                rowHeaders.forEach(rowHeaderText => {
                    const bodyRow = document.createElement('tr');
                    const rowTh = document.createElement('th');
                    rowTh.textContent = rowHeaderText;
                    bodyRow.appendChild(rowTh);

                    const sanitizedRow = sanitizeMoveForId(rowHeaderText);

                    colHeaders.forEach(colHeaderText => {
                        const td = document.createElement('td');
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'custom-checkbox restrict';

                        const sanitizedCol = sanitizeMoveForId(colHeaderText);
                        checkbox.id = `checkbox_move_available_${sanitizedRow}_${sanitizedCol}`;

                        const label = document.createElement('label');
                        label.htmlFor = checkbox.id;

                        if (previousStates.has(checkbox.id)) {
                            checkbox.checked = previousStates.get(checkbox.id);
                        } else {
                            checkbox.checked = shouldBeCheckedByDefault(rowHeaderText, colHeaderText);
                        }

                        td.appendChild(checkbox);
                        td.appendChild(label);
                        bodyRow.appendChild(td);
                    });
                    tbody.appendChild(bodyRow);
                });
            }

            function handleCheckboxChange() {
                updateRestrictTable();
                updateMoveAvailableTable();
                updateUrlParams();
            }

            function initializePage() {
                restrictFieldset.addEventListener('change', handleCheckboxChange);
                tableWrapper.addEventListener('change', handleCheckboxChange);

                moveAvailableTable.addEventListener('change', updateUrlParams);
                const centerRestrictWrapper = document.getElementById('center_restrict_wrapper');
                if (centerRestrictWrapper) {
                    centerRestrictWrapper.addEventListener('change', updateUrlParams);
                }
                updateRestrictTable();
                updateMoveAvailableTable();
            }

            function getMavString() {
                const overrides = [];
                const table = document.getElementById('move_available_table');
                const rows = table.querySelectorAll('tbody tr');

                rows.forEach(row => {
                    const rowHeaderText = row.querySelector('th').textContent;
                    const checkboxes = row.querySelectorAll('input[type="checkbox"]');

                    checkboxes.forEach((checkbox, colIndex) => {
                        const colHeaderText = table.querySelector(`thead th:nth-child(${colIndex + 2})`).textContent;

                        const isActuallyChecked = checkbox.checked;
                        const isDefaultChecked = shouldBeCheckedByDefault(rowHeaderText, colHeaderText);

                        if (isActuallyChecked !== isDefaultChecked) {
                            const sanitizedRow = sanitizeMoveForId(rowHeaderText);
                            const sanitizedCol = sanitizeMoveForId(colHeaderText);
                            overrides.push(`${sanitizedRow}~${sanitizedCol}`);
                        }
                    });
                });

                return overrides.join('|');
            }

            function setMavFromString(mavString) {
                if (!mavString) return;

                const overrides = mavString.split('|');
                overrides.forEach(override => {
                    const parts = override.split('~');
                    if (parts.length !== 2) return;

                    const [sanitizedRow, sanitizedCol] = parts;
                    const checkboxId = `checkbox_move_available_${sanitizedRow}_${sanitizedCol}`;
                    const checkbox = document.getElementById(checkboxId);

                    if (checkbox) {
                        checkbox.checked = !checkbox.checked;
                    }
                });
            }

            function getCrestString() {
                const checkedItems = [];
                const prefix = "checkbox_center_restrict_";

                const checkboxes = document.querySelectorAll('#center_restrict input[type="checkbox"]:checked');

                checkboxes.forEach(cb => {
                    if (cb.id && cb.id.startsWith(prefix)) {
                        checkedItems.push(cb.id.substring(prefix.length));
                    }
                });

                return checkedItems.join('|');
            }

            function setCrestFromString(crestString) {
                document.querySelectorAll('#center_restrict input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });

                const itemsToCheck = crestString.split('|');
                itemsToCheck.forEach(item => {
                    if (item) {
                        const checkboxId = `checkbox_center_restrict_${item}`;
                        const checkbox = document.getElementById(checkboxId);
                        if (checkbox) {
                            checkbox.checked = true;
                        }
                    }
                });
            }

            initializePage();

            window.getIds = getIdsFromCheckboxes;
            window.setIds = setCheckboxesFromIds;
            window.getMavString = getMavString;
            window.setMavFromString = setMavFromString;
            window.getCrestString = getCrestString;
            window.setCrestFromString = setCrestFromString;

        });

        const AXIS_Y = ['U', 'D', 'E', 'u', 'd', 'y'];
        const AXIS_X = ['L', 'R', 'M', 'l', 'r', 'x'];
        const AXIS_Z = ['F', 'B', 'S', 'f', 'b', 'z'];
        const ALL_AXES = [AXIS_Y, AXIS_X, AXIS_Z];

        function getMoveBase(move) {
            if (!move) return '';
            return move.charAt(0);
        }

        function shouldBeCheckedByDefault(prevMove, nextMove) {
            if (!prevMove || !nextMove) {
                return true;
            }

            const prevBase = getMoveBase(prevMove);
            const nextBase = getMoveBase(nextMove);

            if (prevBase === nextBase) {
                return false;
            }

            const axis = ALL_AXES.find(ax => ax.includes(prevBase));
            if (axis && axis.includes(nextBase)) {
                const prevIndex = axis.indexOf(prevBase);
                const nextIndex = axis.indexOf(nextBase);
                if (prevIndex > nextIndex) {
                    return false;
                }
            }

            return true;
        }

        function updateUrlParams() {
            const solver = document.getElementById('solver').value;
            const url = new URL(window.location.href);
            const defaultValueTmp = defaultValues[solver];
            const [resId, restId] = getIds();
            const mavId = getMavString();
            const crestString = getCrestString();
            console.log(crestString);
            idList.forEach(id => {
                const key = idToKeyMap[id];
                var newValue = document.getElementById(id)?.value;
                if (typeof key !== "undefined" && typeof defaultValueTmp[id] !== "undefined") {
                    if (id === 'scr' || id === 'premove') {
                        if (newValue !== '') {
                            newValue = encodeURIComponent(scr_fix2(newValue).replace(/ /g, '_').replace(/'/g, '-'));
                            url.searchParams.set(key, newValue);
                        } else {
                            url.searchParams.delete(key);
                        }
                    } else if (id === 'res') {
                        const rot_string = resId;
                        if (resId !== defaultValueTmp[id]) {
                            url.searchParams.set(key, rot_string);
                        } else {
                            url.searchParams.delete(key);
                        }
                    } else if (id === 'rest') {
                        const rot_string = restId;
                        if (restId !== defaultValueTmp[id]) {
                            url.searchParams.set(key, rot_string);
                        } else {
                            url.searchParams.delete(key);
                        }
                    } else if (id === 'mav') {
                        if (mavId) {
                            url.searchParams.set(key, mavId);
                        } else {
                            url.searchParams.delete(key);
                        }
                    } else if (id === "center_restrict") {
                        if (crestString !== defaultValueTmp[id]) {
                            url.searchParams.set(key, crestString);
                        } else {
                            url.searchParams.delete(key);
                        }
                    } else {
                        if ((document.getElementById(id).tagName === 'SELECT' && document.getElementById(id).selectedIndex > 0) || (document.getElementById(id).tagName === "INPUT" && newValue !== defaultValueTmp[id])) {
                            newValue = newValue.replace(/ /g, '_').replace(/'/g, '-');
                            url.searchParams.set(key, newValue);
                        } else {
                            url.searchParams.delete(key);
                        }
                    }
                } else {
                    url.searchParams.delete(key);
                }
            });
            try {
                window.history.replaceState({}, '', url);
            } catch (e) {
                console.log(e.message);
            }
        }

        function setParamsFromUrl(urlParams) {
            const solver = urlParams.get(idToKeyMap['solver']) ? urlParams.get(idToKeyMap['solver']) : 'F2L';
            document.getElementById('solver').value = solver;
            change();
            document.getElementById('rot').value = urlParams.get(idToKeyMap['rot']) ? urlParams.get(idToKeyMap['rot']).replace(/_/g, ' ').replace(/-/g, '\'') : defaultValues[solver]['rot'];
            if (solver !== "twophase") {
                const premoveParam = urlParams.get(idToKeyMap['premove']);
                if (premoveParam) {
                    document.getElementById('premove').value = decodeURIComponent(premoveParam.replace(/_/g, ' ').replace(/-/g, "'"));
                } else {
                    document.getElementById('premove').value = '';
                }
                document.getElementById('len').value = urlParams.get(idToKeyMap['len']) ? urlParams.get(idToKeyMap['len']) : defaultValues[solver]['len'];
                document.getElementById('num').value = urlParams.get(idToKeyMap['num']) ? urlParams.get(idToKeyMap['num']) : defaultValues[solver]['num'];
                setIds([urlParams.get(idToKeyMap['res']) ? urlParams.get(idToKeyMap['res']) : defaultValues[solver]['res'], urlParams.get(idToKeyMap['rest']) ? urlParams.get(idToKeyMap['rest']) : defaultValues[solver]['rest']]);
                const mavString = urlParams.get(idToKeyMap['mav']);
                if (mavString) {
                    setMavFromString(mavString);
                }
                const crestKey = idToKeyMap['center_restrict'];
                const defaultCrest = 'EMPTY_EMPTY';
                const crestParam = urlParams.get(crestKey);

                setCrestFromString(crestParam ?? defaultCrest);
                document.getElementById('rot_count').value = urlParams.get(idToKeyMap['rot_count']) ? urlParams.get(idToKeyMap['rot_count']) : defaultValues[solver]['rot_count'];
            }
            if (solver === "F2L" || solver === "F2L2") {
                document.getElementById('slot').value = urlParams.get(idToKeyMap['slot']) ? urlParams.get(idToKeyMap['slot']).replace(/_/g, ' ') : defaultValues[solver]['slot'];
            } else if (solver === "F2L_pair") {
                document.getElementById('slot2').value = urlParams.get(idToKeyMap['slot2']) ? urlParams.get(idToKeyMap['slot2']).replace(/_/g, ' ') : defaultValues[solver]['slot2'];
                updateDropdown2();
                if (urlParams.get(idToKeyMap['pair_slot'])) {
                    document.getElementById('pair_slot').value = urlParams.get(idToKeyMap['pair_slot']).replace(/_/g, ' ');
                } else {
                    document.getElementById('pair_slot').selectedIndex = 0;
                }
            } else if (solver === "LS" || solver === "LS2") {
                document.getElementById('ll').value = urlParams.get(idToKeyMap['ll']) ? urlParams.get(idToKeyMap['ll']).replace(/_/g, ' ') : defaultValues[solver]['ll'];
            } else if (solver === "PF2L") {
                document.getElementById('pslot_edge').value = urlParams.get(idToKeyMap['pslot_edge']) ? urlParams.get(idToKeyMap['pslot_edge']).replace(/_/g, ' ') : defaultValues[solver]['pslot_edge'];
                updateDropdown();
                if (urlParams.get(idToKeyMap['pslot_corner'])) {
                    document.getElementById('pslot_corner').value = urlParams.get(idToKeyMap['pslot_corner']).replace(/_/g, ' ');
                } else {
                    document.getElementById('pslot_corner').selectedIndex = 0;
                }
            } else if (solver === "PF2L_pair") {
                document.getElementById('pslot_edge2').value = urlParams.get(idToKeyMap['pslot_edge2']) ? urlParams.get(idToKeyMap['pslot_edge2']).replace(/_/g, ' ') : defaultValues[solver]['pslot_edge2'];
                updateDropdown3();
                if (urlParams.get(idToKeyMap['pslot_corner2'])) {
                    document.getElementById('pslot_corner2').value = urlParams.get(idToKeyMap['pslot_corner2']).replace(/_/g, ' ');
                } else {
                    document.getElementById('pslot_corner2').selectedIndex = 0;
                }
                if (urlParams.get(idToKeyMap['pair_pslot_edge'])) {
                    document.getElementById('pair_pslot_edge').value = urlParams.get(idToKeyMap['pair_pslot_edge']).replace(/_/g, ' ');
                } else {
                    document.getElementById('pair_pslot_edge').selectedIndex = 0;
                }
                updateDropdown4()
                if (urlParams.get(idToKeyMap['pair_pslot_corner'])) {
                    document.getElementById('pair_pslot_corner').value = urlParams.get(idToKeyMap['pair_pslot_corner']).replace(/_/g, ' ');
                } else {
                    document.getElementById('pair_pslot_corner').selectedIndex = 0;
                }
            } else if (solver === "EOCross") {
                document.getElementById('slot_eo').value = urlParams.get(idToKeyMap['slot_eo']) ? urlParams.get(idToKeyMap['slot_eo']).replace(/_/g, ' ') : defaultValues[solver]['slot_eo'];
            }
        }

        function startWorker() {
            try {
                if (worker) {
                    worker.terminate();
                    worker = null;
                    const element = document.getElementById('result');
                    const content = document.createElement('a');
                    content.innerHTML = "Search terminated.<br>";
                    element.appendChild(content);
                    document.getElementById("solveButton").textContent = "Start";
                    return;
                }

                if (typeof convert !== "function" || typeof generateTwoPhaseInput !== "function" || typeof convertMask !== "function") {
                    alert("Error: The required function is not initialized. Please reload the page manually.");
                    const element = document.getElementById('result');
                    const content = document.createElement('a');
                    content.innerHTML = "Error: Search terminated due an error.<br>";
                    element.appendChild(content);
                    document.getElementById("solveButton").textContent = "Start";
                    return;
                }
                document.getElementById("countLine").value = 0;
                document.getElementById("result").innerHTML = "";
                messageCount = 0;
                const solver = document.getElementById('solver').value;
                const scr_val = document.getElementById("scr").value;
                const scr = scr_fix(scr_val);
                const scr2 = scr_fix2(scr_val);
                if (scr === "") {
                    const element = document.getElementById('result');
                    const content = document.createElement('a');
                    content.innerHTML = "Input scramble.<br>";
                    element.appendChild(content);
                    return;
                }
                const rot = document.getElementById('rot').value;
                const slot = document.getElementById('slot').value;
                const slot2 = document.getElementById('slot2').value;
                const slot3 = document.getElementById('slot_eo').value;
                const pair_slot = document.getElementById('pair_slot').value;
                const pslot_e = document.getElementById('pslot_edge').value;
                const pslot_c = document.getElementById('pslot_corner').value;
                const pslot_e2 = document.getElementById('pslot_edge2').value;
                const pslot_c2 = document.getElementById('pslot_corner2').value;
                const pair_pslot_e = document.getElementById('pair_pslot_edge').value;
                const pair_pslot_c = document.getElementById('pair_pslot_corner').value;
                const ll = document.getElementById('ll').value
                const num = document.getElementById('num').value;
                const len = document.getElementById('len').value;
                const restrict = getIds()[1];
                const premove = document.getElementById('premove').value;
                const ma = getMavString();
                const center_offset = getCrestString();
                const max_rot_count = document.getElementById('rot_count').value;
                document.getElementById("solveButton").textContent = "End";
                const convertResult = convert(scr);
                const result_moves = convertResult[0];
                const result_rotation = convertResult[1] + " " + rot;
                if (AutoMaskSetting) {
                    setStickeringOptionAuto();
                } else {
                    setMaskTmp();
                }
                const mask_input = getMaskInputs();
                const convertedMask = convertMask(mask_input.maskInputCenter, mask_input.maskInputEdges, mask_input.maskInputCorners, result_rotation);
                setMask(convertedMask);

                if (solver === "F2L" || solver === "LS" || solver === "LL" || solver == "LU") {
                    const args = { solver: solver, scr: result_moves, rot: rot, slot: slot, ll: ll, num: parseInt(num, 10), len: parseInt(len, 10), move_restrict: restrict, post_alg: premove, center_offset: center_offset, max_rot_count: parseInt(max_rot_count, 10), ma2: ma };
                    worker = new Worker('src_test/crossSolver/worker.js');
                    worker.postMessage(args);
                } else if (solver === "F2L2" || solver === "LS2" || solver === "LL2" || solver == "LU2") {
                    const args = { solver: solver, scr: result_moves, rot: rot, slot: slot, ll: ll, num: parseInt(num, 10), len: parseInt(len, 10), move_restrict: restrict, post_alg: premove, center_offset: center_offset, max_rot_count: parseInt(max_rot_count, 10), ma2: ma };
                    worker = new Worker('src_test/highMemorySolver/worker2.js');
                    worker.postMessage(args);
                } else if (solver === "PF2L") {
                    const args = { scr: result_moves, rot: rot, slot: pslot_e, pslot: pslot_c, num: parseInt(num, 10), len: parseInt(len, 10), move_restrict: restrict, post_alg: premove, center_offset: center_offset, max_rot_count: parseInt(max_rot_count, 10), ma2: ma };
                    worker = new Worker('src_test/pseudoCrossSolver/worker3.js');
                    worker.postMessage(args);
                } else if (solver === "F2L_pair") {
                    const args = { scr: result_moves, rot: rot, slot: slot2, pslot: pair_slot, num: parseInt(num, 10), len: parseInt(len, 10), move_restrict: restrict, post_alg: premove, center_offset: center_offset, max_rot_count: parseInt(max_rot_count, 10), ma2: ma };
                    worker = new Worker('src_test/F2L_PairingSolver/worker_pairing.js');
                    worker.postMessage(args);
                } else if (solver === "PF2L_pair") {
                    const args = { scr: result_moves, rot: rot, slot: pslot_e2, pslot: pslot_c2, a_slot: pair_pslot_e, a_pslot: pair_pslot_c, num: parseInt(num, 10), len: parseInt(len, 10), move_restrict: restrict, post_alg: premove, center_offset: center_offset, max_rot_count: parseInt(max_rot_count, 10), ma2: ma };
                    worker = new Worker('src_test/pseudoPairingSolver/workerPseudoPairing.js');
                    worker.postMessage(args);
                } else if (solver === "twophase") {
                    const sol = min2phase.solve(generateTwoPhaseInput(convert(scr + " " + rot)[0]));
                    appendSol(scr2, rot + " " + sol);
                    const element = document.getElementById('result');
                    const content = document.createElement('a');
                    content.textContent = "Search terminated.";
                    element.appendChild(content);
                    document.getElementById("solveButton").textContent = "Start";
                } else if (solver === "EOCross") {
                    const args = { scr: result_moves, rot: rot, slot: slot3, num: parseInt(num, 10), len: parseInt(len, 10), move_restrict: restrict, post_alg: premove, center_offset: center_offset, max_rot_count: parseInt(max_rot_count, 10), ma2: ma };
                    worker = new Worker("src_test/EOCrossSolver/worker.js");
                    worker.postMessage(args);
                }
                if (worker) {
                    worker.onmessage = function (event) {
                        appendSol(scr2, event.data);
                    };
                }
            } catch (e) {
                console.log(e.message);
                if (worker) {
                    worker.terminate();
                }
                worker = null;
                const element = document.getElementById('result');
                const content = document.createElement('a');
                content.innerHTML = "Error: Search terminated due an error.<br>";
                element.appendChild(content);
                document.getElementById("solveButton").textContent = "Start";
                return;
            }
        }

        function appendSol(scr, sol) {
            const element = document.getElementById('result');
            if (sol == "Search finished." || sol == "Already solved." || sol == "Error" || sol == "Unsolvable.") {
                if (worker) {
                    worker.terminate();
                }
                worker = null;
                const element = document.getElementById('result');
                const content = document.createElement('a');
                if (sol == "Error") {
                    content.innerHTML = "Error: Search terminated due to an error.<br>";
                } else if (sol === "Already solved.") {
                    content.innerHTML = "Already solved.<br>";
                } else if (sol === "Search finished.") {
                    content.innerHTML = "Search finished.<br>";
                } else {
                    content.innerHTML = "Unsolvable.<br>";
                }
                element.appendChild(content);
                document.getElementById("solveButton").textContent = "Start";
                return;
            } else {
                messageCount++;
                const details = document.createElement('details');
                if (messageCount === 1 || sol_input) {
                    details.setAttribute('open', '');
                }
                const summary = document.createElement('summary');
                summary.textContent = messageCount + ": " + sol;
                summary.setAttribute('translate', 'no');
                const textNode = document.createTextNode(messageCount + ": " + sol);
                const button = document.createElement('button');
                button.classList.add('button', 'medium');
                button.textContent = 'Add';
                button.onclick = function () {
                    add(sol);
                };
                details.appendChild(button);
                details.appendChild(summary);
                try {
                    const sim = createPlayer(scr, sol);
                    sim.experimentalStickeringMaskOrbits = mask;
                    details.appendChild(sim);
                } catch (e) {
                    if (messageCount === 1) {
                        const lineBreak = document.createElement('br');
                        details.appendChild(lineBreak);
                        const content = document.createElement('a');
                        content.innerHTML = "Warning: Failed to create TwistyPlayer.<br>";
                        details.appendChild(content);
                    }
                }
                const { URL1: link1, URL2: link2 } = getLink(scr + "\n" + sol);
                var link_element1 = document.createElement('a');
                link_element1.href = link1;
                link_element1.target = '_blank';
                link_element1.rel = 'noopener noreferrer';
                link_element1.textContent = 'alg.cubing.net';
                link_element1.setAttribute('translate', 'no');
                details.appendChild(link_element1);
                var spaceElement = document.createElement('a');
                spaceElement.innerHTML = "&nbsp;";
                details.appendChild(spaceElement);
                var link_element2 = document.createElement('a');
                link_element2.href = link2;
                link_element2.target = '_blank';
                link_element2.rel = 'noopener noreferrer';
                link_element2.textContent = 'cubedb.net';
                link_element2.setAttribute('translate', 'no');
                details.appendChild(link_element2);
                var spaceElement2 = document.createElement('a');
                spaceElement2.innerHTML = "&nbsp;";
                details.appendChild(spaceElement2);
                const currentUrl = new URL(window.location.href);
                currentUrl.searchParams.set('index', `${messageCount}`);
                currentUrl.searchParams.set('sol', sol.replace(/ /g, '_').replace(/'/g, '-'));
                var link_element3 = document.createElement('a');
                link_element3.href = currentUrl;
                link_element3.target = '_blank';
                link_element3.rel = 'noopener noreferrer';
                link_element3.textContent = 'or18.github.io';
                link_element3.setAttribute('translate', 'no');
                details.appendChild(link_element3);
                element.appendChild(details);
                document.getElementById("countLine").value = messageCount;
                if (messageCount === 1) {
                    try {
                        window.history.replaceState({}, '', currentUrl);
                    } catch (e) {
                        console.log(e.message);
                    }
                }
            }
        }

        function change() {
            const selectedValue = document.getElementById("solver").value;
            document.getElementById("basic input").classList.remove("hidden");
            document.getElementById("tp_alert").classList.add("hidden");
            document.getElementById("option_for_F2L").classList.add("hidden");
            document.getElementById("option_for_F2L2").classList.add("hidden");
            document.getElementById("option_for_LS").classList.add("hidden");
            document.getElementById("analyze").classList.add("hidden");
            document.getElementById("eo_analyze").classList.add("hidden");
            document.getElementById("panalyze").classList.add("hidden");
            document.getElementById("option_for_PF2L").classList.add("hidden");
            document.getElementById("option_for_PF2L2").classList.add("hidden");
            document.getElementById("option_for_pair_F2L").classList.add("hidden");
            document.getElementById("option_for_pair_PF2L").classList.add("hidden");
            document.getElementById("pair_analyze").classList.add("hidden");
            document.getElementById("pair_panalyze").classList.add("hidden");
            document.getElementById("tp_alert").classList.add("hidden");
            document.getElementById('option_for_eocross').classList.add("hidden");
            if (selectedValue === "F2L" || selectedValue === "F2L2") {
                document.getElementById("option_for_F2L").classList.remove("hidden");
                document.getElementById("analyze").classList.remove("hidden");
            } else if (selectedValue === "LS" || selectedValue === "LS2") {
                document.getElementById("option_for_LS").classList.remove("hidden");
            } else if (selectedValue === "PF2L") {
                document.getElementById("option_for_PF2L").classList.remove("hidden");
                document.getElementById("panalyze").classList.remove("hidden");
            } else if (selectedValue === "F2L_pair") {
                document.getElementById("option_for_F2L2").classList.remove("hidden");
                document.getElementById("option_for_pair_F2L").classList.remove("hidden");
                document.getElementById("pair_analyze").classList.remove("hidden");
            } else if (selectedValue === "PF2L_pair") {
                document.getElementById("option_for_PF2L2").classList.remove("hidden");
                document.getElementById("option_for_pair_PF2L").classList.remove("hidden");
                document.getElementById("pair_panalyze").classList.remove("hidden");
            } else if (selectedValue === "twophase") {
                document.getElementById("tp_alert").classList.remove("hidden");
                document.getElementById("basic input").classList.add("hidden");
            } else if (selectedValue === "EOCross") {
                document.getElementById('option_for_eocross').classList.remove("hidden");
                document.getElementById("eo_analyze").classList.remove("hidden");
            }
        }

        const textarea = document.getElementById('scr');
        const undoButton = document.getElementById('undo');
        const redoButton = document.getElementById('redo');
        let history_input = [];
        let currentIndex = -1;

        function save() {
            if (currentIndex < history_input.length - 1) {
                history_input = history_input.slice(0, currentIndex + 1);
            }
            history_input.push(textarea.value);
            currentIndex++;
            updateButtons();
            try {
                document.getElementById('show').innerHTML = '';
                const sim = createPlayer(scr_fix2(textarea.value), '');
                sim.controlPanel = "none";
                document.getElementById('show').appendChild(sim);
            } catch (e) {
                const content = document.createElement('a');
                content.innerHTML = "Warning: Failed to create TwistyPlayer.<br>";
                document.getElementById('show').appendChild(content);
            }
        }

        function generateTwoPhaseInputWrapper(scr) {
            if (typeof generateTwoPhaseInput !== "function") {
                alert("Error: The required function is not initialized. Please reload the page manually.");
                return;
            } else {
                return generateTwoPhaseInput(scr);
            }
        }

        function genscr() {
            var cube = min2phase.randomCube();
            var solution = min2phase.solve(cube);
            var sol_reversed = min2phase.solve(generateTwoPhaseInputWrapper(solution));
            document.getElementById('scr').value = scr_fix2(sol_reversed) + " // setup\n";
            save();
        }

        function analyze() {
            try {
                if (worker2) {
                    worker2.terminate();
                    worker2 = null;
                    document.getElementById("analyzer").textContent = "Analyze";
                    if (messageCount_analyzer > 0) {
                        option_table = {
                            valueNames: ["No", "slot", "D", "U", "L", "R", "F", "B"]
                        };
                        list_table = new List('table', option_table);
                    }
                    return;
                }

                if (typeof convert !== "function") {
                    alert("Error: The required function is not initialized. Please reload the page manually.");
                    document.getElementById("analyzer").textContent = "Analyze";
                    const error_message = "<br><a>Analyzer terminated due to an error.</a><br>";
                    document.getElementById('table').innerHTML += error_message;
                    return;
                }
                const content = "<a>Hint: Click a cell to start the search with that condition, and click the header to sort.</a><br>";
                document.getElementById('table').innerHTML = content;
                let scr = document.getElementById("scr").value;
                const scramble = scr_fix(scr);
                const option = document.getElementById('analyzer_option').value;
                const checkboxes = document.querySelectorAll('#analyzer_rotation_option .analyzer');
                const values = [];
                checkboxes.forEach(function (checkbox) {
                    if (checkbox.checked) {
                        values.push(checkbox.value);
                    }
                });
                const rot_set = values.join('');
                const sol_num = document.getElementById("analyzer_num").value;
                messageCount_analyzer = -2;
                document.getElementById('table').innerHTML += "<a>Solved: </a>";
                const input = document.createElement('input');
                input.type = 'text';
                input.id = 'count_analyzer';
                input.readOnly = true;
                const input2 = document.createElement('input');
                input2.type = 'text';
                input2.id = 'count_analyzer_max';
                input2.readOnly = true;
                document.getElementById('table').appendChild(input);
                document.getElementById('table').innerHTML += "<a>/</a>";
                document.getElementById('table').appendChild(input2);
                worker2 = new Worker('src/crossAnalyzer/worker_analyzer.js');
                document.getElementById("analyzer").textContent = "End";
                worker2.onmessage = function (event) {
                    if (event.data == "Error") {
                        if (worker2) {
                            worker2.terminate();
                        }
                        worker2 = null;
                        document.getElementById("analyzer").textContent = "Analyze";
                        if (messageCount_analyzer > 0) {
                            option_table = {
                                valueNames: ["No", "slot", "D", "U", "L", "R", "F", "B"]
                            };
                            list_table = new List('table', option_table);
                        }
                        const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                        document.getElementById('table').innerHTML += error_message;
                        return;
                    } else if (messageCount_analyzer === -2) {
                        messageCount_analyzer++;
                        document.getElementById('table').innerHTML += event.data;
                    } else if (messageCount_analyzer === -1) {
                        messageCount_analyzer++;
                        document.getElementById("count_analyzer_max").value = event.data;
                    } else if (event.data === "Finished.") {
                        if (worker2) {
                            worker2.terminate();
                            worker2 = null;
                            document.getElementById("analyzer").textContent = "Analyze";
                            option_table = {
                                valueNames: ["No", "slot", "D", "U", "L", "R", "F", "B"]
                            };
                            list_table = new List('table', option_table);
                            return;
                        }
                    } else {
                        messageCount_analyzer++;
                        document.querySelector('#analyzer_result tbody').insertAdjacentHTML('beforeend', event.data);
                        document.getElementById("count_analyzer").value = messageCount_analyzer;
                    }
                };
                let cross = false;
                let xcross = false;
                let xxcross = false;
                let xxxcross = false;
                if (option === "cross" || option == "2x" || option === "3x" || option === "4x") {
                    cross = true;
                }
                if (option === "xcross" || option == "2x" || option === "3x" || option === "4x") {
                    xcross = true;
                }
                if (option === "xxcross" || option === "3x" || option === "4x") {
                    xxcross = true;
                }
                if (option === "xxxcross" || option === "4x") {
                    xxxcross = true;
                }
                const args = { scramble: convert(scramble)[0], cross: cross, x: xcross, xx: xxcross, xxx: xxxcross, n: sol_num, rot_set: rot_set };
                worker2.postMessage(args);
            } catch (e) {
                console.log(e.message);
                if (worker2) {
                    worker2.terminate();
                }
                worker2 = null;
                document.getElementById("analyzer").textContent = "Analyze";
                if (messageCount_analyzer > 0) {
                    option_table = {
                        valueNames: ["No", "slot", "D", "U", "L", "R", "F", "B"]
                    };
                    list_table = new List('table', option_table);
                }
                const error_message = "<br><a>AError: nalyzer terminated due to an error.</a><br>";
                document.getElementById('table').innerHTML += error_message;
                return;
            }
        }

        function initializeForAnalyzer(defaults) {
            setIds([defaults.res, defaults.rest]);
            setMavFromString(defaults.mav);
            setCrestFromString(defaults.center_restrict);
        }

        function solve(slot_option, rotation_option) {
            document.getElementById("solver").value = "F2L";
            document.getElementById('rot').value = rotation_option;
            document.getElementById('slot').value = slot_option;
            document.getElementById('num').value = 20;
            document.getElementById('len').value = 20;
            document.getElementById('premove').value = '';
            document.getElementById('rot_count').value = '0';
            initializeForAnalyzer(defaultValues['F2L']);
            updateUrlParams();
            if (worker) {
                startWorker();
            }
            startWorker();
        }

        function reverseScramble() {
            if (typeof reverse !== "function") {
                alert("Error: The required function is not initialized. Please reload the page manually.");
                return;
            }
            const scr_val = document.getElementById("scr").value;
            const scr = scr_fix2(scr_val);
            if (scr === "") {
                return;
            }
            document.getElementById("scr").value = reverse(scr);
            save();
        }

        function mirrorScramble() {
            if (typeof mirror !== "function") {
                alert("Error: The required function is not initialized. Please reload the page manually.");
                return;
            }
            const scr_val = document.getElementById("scr").value;
            const scr = scr_fix2(scr_val);
            if (scr === "") {
                return;
            }
            document.getElementById("scr").value = mirror(scr);
            save();
        }

        function undo() {
            if (currentIndex > 0) {
                currentIndex--;
                textarea.value = history_input[currentIndex];
                updateButtons();
                try {
                    document.getElementById('show').innerHTML = '';
                    const sim = createPlayer(scr_fix2(textarea.value), '');
                    sim.controlPanel = "none";
                    document.getElementById('show').appendChild(sim);
                } catch (e) {
                    const content = document.createElement('a');
                    content.innerHTML = "Warning: Failed to create TwistyPlayer.<br>";
                    document.getElementById('show').appendChild(content);
                }
            }
        }

        function redo() {
            if (currentIndex < history_input.length - 1) {
                currentIndex++;
                textarea.value = history_input[currentIndex];
                updateButtons();
                try {
                    document.getElementById('show').innerHTML = '';
                    const sim = createPlayer(scr_fix2(textarea.value), '');
                    sim.controlPanel = "none";
                    document.getElementById('show').appendChild(sim);
                } catch (e) {
                    const content = document.createElement('a');
                    content.innerHTML = "Warning: Failed to create TwistyPlayer.<br>";
                    document.getElementById('show').appendChild(content);
                }
            }
        }

        function updateButtons() {
            undoButton.disabled = currentIndex <= 0;
            redoButton.disabled = currentIndex >= history_input.length - 1;
            const currentScr = document.getElementById("scr").value;
            if (currentScr === "") {
                document.getElementById("reverse").classList.add("hidden");
                document.getElementById("mirror").classList.add("hidden");
            } else {
                document.getElementById("reverse").classList.remove("hidden");
                document.getElementById("mirror").classList.remove("hidden");
            }
            updateUrlParams();
            if (currentIndex <= 0) {
                undoButton.classList.add("hidden_small");
            } else {
                undoButton.classList.remove("hidden_small");
            }
            if (currentIndex >= history_input.length - 1) {
                redoButton.classList.add("hidden_small")
            } else {
                redoButton.classList.remove("hidden_small");
            }
            if (currentIndex >= 0) {
                const { URL1: link1, URL2: link2 } = getLink(currentScr);
                document.getElementById("link_alg_cubing").href = link1;
                document.getElementById("link_cubedb").href = link2;
                document.getElementById("links").classList.remove("hidden");
            }
        }


        function updateDropdown() {
            const dropdownA = document.getElementById("pslot_edge");
            const dropdownB = document.getElementById("pslot_corner");
            document.getElementById("option_for_PF2LC").classList.add("hidden");
            const selectedValue = dropdownA.value;
            dropdownB.innerHTML = "";
            let options = [];
            if (selectedValue === "") {
                options = [
                    { value: "", text: "" },
                ];
            } else if (selectedValue === "BL" || selectedValue === "BR" || selectedValue === "FR" || selectedValue === "FL") {
                options = [
                    { value: "BL", text: "BL" },
                    { value: "BR", text: "BR" },
                    { value: "FR", text: "FR" },
                    { value: "FL", text: "FL" }
                ];
            } else if (selectedValue === "BL BR" || selectedValue === "BL FR" || selectedValue === "BL FL" || selectedValue === "BR FR" || selectedValue === "BR FL" || selectedValue === "FR FL") {
                options = [
                    { value: "BL BR", text: "BL BR" },
                    { value: "BL FR", text: "BL FR" },
                    { value: "BL FL", text: "BL FL" },
                    { value: "BR FR", text: "BR FR" },
                    { value: "BR FL", text: "BR FL" },
                    { value: "FR FL", text: "FR FL" }
                ];
            } else if (selectedValue === "BL BR FR" || selectedValue === "BL BR FL" || selectedValue === "BL FR FL" || selectedValue === "BR FR FL") {
                options = [
                    { value: "BL BR FR", text: "BL BR FR" },
                    { value: "BL BR FL", text: "BL BR FL" },
                    { value: "BL FR FL", text: "BL FR FL" },
                    { value: "BR FR FL", text: "BR FR FL" }
                ];
            }

            options.forEach(option => {
                const newOption = document.createElement("option");
                newOption.value = option.value;
                newOption.textContent = option.text;
                dropdownB.appendChild(newOption);
            });

            if (selectedValue !== "") {
                document.getElementById("option_for_PF2LC").classList.remove("hidden");
            }
        }

        function updateDropdown2() {
            const dropdownA = document.getElementById("slot2");
            const dropdownB = document.getElementById("pair_slot");
            const selectedValue = dropdownA.value;
            let selectedValueArray = selectedValue.split(" ");
            dropdownB.innerHTML = "";
            let options = [
                { value: "BL", text: "BL" },
                { value: "BR", text: "BR" },
                { value: "FR", text: "FR" },
                { value: "FL", text: "FL" }
            ];
            options = options.filter(option => !selectedValueArray.includes(option.value));
            options.forEach(option => {
                const newOption = document.createElement("option");
                newOption.value = option.value;
                newOption.textContent = option.text;
                dropdownB.appendChild(newOption);
            });
        }

        function updateDropdown3() {
            const dropdownA = document.getElementById("pslot_edge2");
            let dropdownB = document.getElementById("pslot_corner2");
            document.getElementById("option_for_PF2LC2").classList.add("hidden");
            let selectedValue = dropdownA.value;
            dropdownB.innerHTML = "";
            let options = [];
            if (selectedValue === "") {
                options = [
                    { value: "", text: "" },
                ];
            } else if (selectedValue === "BL" || selectedValue === "BR" || selectedValue === "FR" || selectedValue === "FL") {
                options = [
                    { value: "BL", text: "BL" },
                    { value: "BR", text: "BR" },
                    { value: "FR", text: "FR" },
                    { value: "FL", text: "FL" }
                ];
            } else if (selectedValue === "BL BR" || selectedValue === "BL FR" || selectedValue === "BL FL" || selectedValue === "BR FR" || selectedValue === "BR FL" || selectedValue === "FR FL") {
                options = [
                    { value: "BL BR", text: "BL BR" },
                    { value: "BL FR", text: "BL FR" },
                    { value: "BL FL", text: "BL FL" },
                    { value: "BR FR", text: "BR FR" },
                    { value: "BR FL", text: "BR FL" },
                    { value: "FR FL", text: "FR FL" }
                ];
            } else if (selectedValue === "BL BR FR" || selectedValue === "BL BR FL" || selectedValue === "BL FR FL" || selectedValue === "BR FR FL") {
                options = [
                    { value: "BL BR FR", text: "BL BR FR" },
                    { value: "BL BR FL", text: "BL BR FL" },
                    { value: "BL FR FL", text: "BL FR FL" },
                    { value: "BR FR FL", text: "BR FR FL" }
                ];
            }

            options.forEach(option => {
                const newOption = document.createElement("option");
                newOption.value = option.value;
                newOption.textContent = option.text;
                dropdownB.appendChild(newOption);
            });

            if (selectedValue !== "") {
                document.getElementById("option_for_PF2LC2").classList.remove("hidden");
            }

            dropdownB = document.getElementById("pair_pslot_edge");
            selectedValue = dropdownA.value;
            let selectedValueArray = selectedValue.split(" ");
            dropdownB.innerHTML = "";
            options = [
                { value: "BL", text: "BL" },
                { value: "BR", text: "BR" },
                { value: "FR", text: "FR" },
                { value: "FL", text: "FL" }
            ];
            options = options.filter(option => !selectedValueArray.includes(option.value));
            options.forEach(option => {
                const newOption = document.createElement("option");
                newOption.value = option.value;
                newOption.textContent = option.text;
                dropdownB.appendChild(newOption);
            });
            updateDropdown4();
        }

        function updateDropdown4() {
            const dropdownA = document.getElementById("pslot_corner2");
            const dropdownB = document.getElementById("pair_pslot_corner");
            const selectedValue = dropdownA.value;
            let selectedValueArray = selectedValue.split(" ");
            dropdownB.innerHTML = "";
            let options = [
                { value: "BL", text: "BL" },
                { value: "BR", text: "BR" },
                { value: "FR", text: "FR" },
                { value: "FL", text: "FL" }
            ];
            options = options.filter(option => !selectedValueArray.includes(option.value));
            options.forEach(option => {
                const newOption = document.createElement("option");
                newOption.value = option.value;
                newOption.textContent = option.text;
                dropdownB.appendChild(newOption);
            });
        }

        function panalyze() {
            try {
                if (worker3) {
                    worker3.terminate();
                    worker3 = null;
                    document.getElementById("panalyzer").textContent = "Analyze";
                    if (messageCount_panalyzer > 0) {
                        option_ptable = {
                            valueNames: ["No", "slot", "pslot", "D", "U", "L", "R", "F", "B"]
                        };
                        list_ptable = new List('ptable', option_ptable);
                    }
                    return;
                }
                if (typeof convert !== "function") {
                    alert("Error: The required function is not initialized. Please reload the page manually.");
                    document.getElementById("panalyzer").textContent = "Analyze";
                    const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                    document.getElementById('ptable').innerHTML += error_message;
                    return;
                }
                const content = "<a>Hint: Click a cell to start the search with that condition, and click the header to sort.</a><br>";
                document.getElementById('ptable').innerHTML = content;
                let scr = document.getElementById("scr").value;
                const scramble = scr_fix(scr);
                const option = document.getElementById('panalyzer_option').value;
                const checkboxes = document.querySelectorAll('#panalyzer_rotation_option .panalyzer');
                const values = [];
                checkboxes.forEach(function (checkbox) {
                    if (checkbox.checked) {
                        values.push(checkbox.value);
                    }
                });
                const rot_set = values.join('');
                const sol_num = document.getElementById("panalyzer_num").value;
                messageCount_panalyzer = -2;
                document.getElementById('ptable').innerHTML += "<a>Solved: </a>";
                const input = document.createElement('input');
                input.type = 'text';
                input.id = 'count_panalyzer';
                input.readOnly = true;
                const input2 = document.createElement('input');
                input2.type = 'text';
                input2.id = 'count_panalyzer_max';
                input2.readOnly = true;
                document.getElementById('ptable').appendChild(input);
                document.getElementById('ptable').innerHTML += "<a>/</a>";
                document.getElementById('ptable').appendChild(input2);
                worker3 = new Worker('src/pseudoCrossAnalyzer/worker_panalyzer.js');
                document.getElementById("panalyzer").textContent = "End";
                worker3.onmessage = function (event) {
                    if (event.data == "Error") {
                        if (worker3) {
                            worker3.terminate();
                        }
                        worker3 = null;
                        document.getElementById("panalyzer").textContent = "Analyze";
                        if (messageCount_panalyzer > 0) {
                            option_ptable = {
                                valueNames: ["No", "slot", "pslot", "D", "U", "L", "R", "F", "B"]
                            };
                            list_ptable = new List('ptable', option_ptable);
                        }
                        const error_message = "<br><a>Analyzer terminated due to an error.</a><br>";
                        document.getElementById('ptable').innerHTML += error_message;
                        return;
                    } else if (messageCount_panalyzer === -2) {
                        messageCount_panalyzer++;
                        document.getElementById('ptable').innerHTML += event.data;
                    } else if (messageCount_panalyzer === -1) {
                        messageCount_panalyzer++;
                        document.getElementById("count_panalyzer_max").value = event.data;
                    } else if (event.data === "Finished.") {
                        if (worker3) {
                            worker3.terminate();
                            worker3 = null;
                            document.getElementById("panalyzer").textContent = "Analyze";
                            option_ptable = {
                                valueNames: ["No", "slot", "pslot", "D", "U", "L", "R", "F", "B"]
                            };
                            list_ptable = new List('ptable', option_ptable);
                            return;
                        }
                    } else {
                        messageCount_panalyzer++;
                        document.querySelector('#panalyzer_result tbody').insertAdjacentHTML('beforeend', event.data);
                        document.getElementById("count_panalyzer").value = messageCount_panalyzer;
                    }
                };
                let cross = false;
                let xcross = false;
                let xxcross = false;
                let xxxcross = false;
                if (option === "cross" || option == "2x" || option === "3x" || option === "4x") {
                    cross = true;
                }
                if (option === "xcross" || option == "2x" || option === "3x" || option === "4x") {
                    xcross = true;
                }
                if (option === "xxcross" || option === "3x" || option === "4x") {
                    xxcross = true;
                }
                if (option === "xxxcross" || option === "4x") {
                    xxxcross = true;
                }
                const args = { scramble: convert(scramble)[0], cross: cross, x: xcross, xx: xxcross, xxx: xxxcross, n: sol_num, rot_set: rot_set };
                worker3.postMessage(args);
            } catch (e) {
                console.log(e.message);
                if (worker3) {
                    worker3.terminate();
                }
                worker3 = null;
                document.getElementById("panalyzer").textContent = "Analyze";
                if (messageCount_panalyzer > 0) {
                    option_ptable = {
                        valueNames: ["No", "slot", "pslot", "D", "U", "L", "R", "F", "B"]
                    };
                    list_ptable = new List('ptable', option_ptable);
                }
                const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                document.getElementById('ptable').innerHTML += error_message;
                return;
            }
        }

        function psolve(slot_option, pslot_option, rotation_option) {
            document.getElementById("solver").value = "PF2L";
            document.getElementById('rot').value = rotation_option;
            document.getElementById('pslot_edge').value = slot_option;
            updateDropdown();
            document.getElementById('pslot_corner').value = pslot_option;
            document.getElementById('num').value = 20;
            document.getElementById('len').value = 20;
            document.getElementById('premove').value = '';
            document.getElementById('rot_count').value = '0';
            initializeForAnalyzer(defaultValues['PF2L']);
            updateUrlParams();
            if (worker) {
                startWorker();
            }
            startWorker();
        }

        function pair_analyze() {
            try {
                if (worker4) {
                    worker4.terminate();
                    worker4 = null;
                    document.getElementById("pair_analyzer").textContent = "Analyze";
                    if (messageCount_pair_analyzer > 0) {
                        option_pair_table = {
                            valueNames: ["No", "slot", "pslot", "D", "U", "L", "R", "F", "B"]
                        };
                        list_pair_table = new List('pair_table', option_pair_table);
                    }
                    return;
                }
                if (typeof convert !== "function") {
                    alert("Error: The required function is not initialized. Please reload the page manually.");
                    document.getElementById("pair_analyzer").textContent = "Analyze";
                    const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                    document.getElementById('pair_table').innerHTML += error_message;
                    return;
                }
                const content = "<a>Hint: Click a cell to start the search with that condition, and click the header to sort.</a><br>";
                document.getElementById('pair_table').innerHTML = content;
                let scr = document.getElementById("scr").value;
                const scramble = scr_fix(scr);
                const option = document.getElementById('pair_analyzer_option').value;
                const checkboxes = document.querySelectorAll('#pair_analyzer_rotation_option .pair_analyzer');
                const values = [];
                checkboxes.forEach(function (checkbox) {
                    if (checkbox.checked) {
                        values.push(checkbox.value);
                    }
                });
                const rot_set = values.join('');
                const sol_num = document.getElementById("pair_analyzer_num").value;
                messageCount_pair_analyzer = -2;
                document.getElementById('pair_table').innerHTML += "<a>Solved: </a>";
                const input = document.createElement('input');
                input.type = 'text';
                input.id = 'count_pair_analyzer';
                input.readOnly = true;
                const input2 = document.createElement('input');
                input2.type = 'text';
                input2.id = 'count_pair_analyzer_max';
                input2.readOnly = true;
                document.getElementById('pair_table').appendChild(input);
                document.getElementById('pair_table').innerHTML += "<a>/</a>";
                document.getElementById('pair_table').appendChild(input2);
                worker4 = new Worker('src/pairAnalyzer/worker_analyzer.js');
                document.getElementById("pair_analyzer").textContent = "End";
                worker4.onmessage = function (event) {
                    if (event.data == "Error") {
                        if (worker4) {
                            worker4.terminate();
                        }
                        worker4 = null;
                        document.getElementById("pair_analyzer").textContent = "Analyze";
                        const error_message = "<br><a>Analyzer terminated due to an error.</a><br>";
                        document.getElementById('pair_table').innerHTML += error_message;
                        return;
                    } else if (messageCount_pair_analyzer === -2) {
                        messageCount_pair_analyzer++;
                        document.getElementById('pair_table').innerHTML += event.data;
                    } else if (messageCount_pair_analyzer === -1) {
                        messageCount_pair_analyzer++;
                        document.getElementById("count_pair_analyzer_max").value = event.data;
                    } else if (event.data === "Finished.") {
                        if (worker4) {
                            worker4.terminate();
                            worker4 = null;
                            document.getElementById("pair_analyzer").textContent = "Analyze";
                            if (messageCount_pair_analyzer > 0) {
                                option_pair_table = {
                                    valueNames: ["No", "slot", "pslot", "D", "U", "L", "R", "F", "B"]
                                };
                                list_pair_table = new List('pair_table', option_pair_table);
                            }
                            return;
                        }
                    } else {
                        messageCount_pair_analyzer++;
                        document.querySelector('#pair_analyzer_result tbody').insertAdjacentHTML('beforeend', event.data);
                        document.getElementById("count_pair_analyzer").value = messageCount_pair_analyzer;
                    }
                };
                let cross = false;
                let xcross = false;
                let xxcross = false;
                let xxxcross = false;
                if (option === "cross" || option == "2x" || option === "3x" || option === "4x") {
                    cross = true;
                }
                if (option === "xcross" || option == "2x" || option === "3x" || option === "4x") {
                    xcross = true;
                }
                if (option === "xxcross" || option === "3x" || option === "4x") {
                    xxcross = true;
                }
                if (option === "xxxcross" || option === "4x") {
                    xxxcross = true;
                }
                const args = { scramble: convert(scramble)[0], cross: cross, x: xcross, xx: xxcross, xxx: xxxcross, n: sol_num, rot_set: rot_set };
                worker4.postMessage(args);
            } catch (e) {
                console.log(e.message);
                if (worker4) {
                    worker4.terminate();
                }
                worker4 = null;
                document.getElementById("pair_analyzer").textContent = "Analyze";
                if (messageCount_pair_analyzer > 0) {
                    option_pair_table = {
                        valueNames: ["No", "slot", "pslot", "D", "U", "L", "R", "F", "B"]
                    };
                    list_pair_table = new List('pair_table', option_pair_table);
                }
                const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                document.getElementById('pair_table').innerHTML += error_message;
                return;
            }
        }

        function pair_solve(slot_option, pslot_option, rotation_option) {
            document.getElementById("solver").value = "F2L_pair";
            document.getElementById('rot').value = rotation_option;
            document.getElementById('slot2').value = slot_option;
            updateDropdown2();
            document.getElementById('pair_slot').value = pslot_option;
            document.getElementById('num').value = 20;
            document.getElementById('len').value = 20;
            document.getElementById('premove').value = '';
            document.getElementById('rot_count').value = '0';
            initializeForAnalyzer(defaultValues['F2L_pair']);
            updateUrlParams();
            if (worker) {
                startWorker();
            }
            startWorker();
        }

        function pair_panalyze() {
            try {
                if (worker5) {
                    worker5.terminate();
                    worker5 = null;
                    document.getElementById("pair_panalyzer").textContent = "Analyze";
                    if (messageCount_pair_panalyzer > 0) {
                        option_pair_ptable = {
                            valueNames: ["No", "slot", "pslot", "a_slot", "a_pslot", "D", "U", "L", "R", "F", "B"]
                        };
                        list_pair_ptable = new List('pair_ptable', option_pair_ptable);
                    }
                    return;
                }
                if (typeof convert !== "function") {
                    alert("Error: The required function is not initialized. Please reload the page manually.");
                    document.getElementById("pair_panalyzer").textContent = "Analyze";
                    const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                    document.getElementById('pair_ptable').innerHTML += error_message;
                    return;
                }
                const content = "<a>Hint: Click a cell to start the search with that condition, and click the header to sort.</a><br>";
                document.getElementById('pair_ptable').innerHTML = content;
                let scr = document.getElementById("scr").value;
                const scramble = scr_fix(scr);
                const option = document.getElementById('pair_panalyzer_option').value;
                const checkboxes = document.querySelectorAll('#pair_panalyzer_rotation_option .pair_panalyzer');
                const values = [];
                checkboxes.forEach(function (checkbox) {
                    if (checkbox.checked) {
                        values.push(checkbox.value);
                    }
                });
                const rot_set = values.join('');
                const sol_num = document.getElementById("pair_panalyzer_num").value;
                messageCount_pair_panalyzer = -2;
                document.getElementById('pair_ptable').innerHTML += "<a>Solved: </a>";
                const input = document.createElement('input');
                input.type = 'text';
                input.id = 'count_pair_panalyzer';
                input.readOnly = true;
                const input2 = document.createElement('input');
                input2.type = 'text';
                input2.id = 'count_pair_panalyzer_max';
                input2.readOnly = true;
                document.getElementById('pair_ptable').appendChild(input);
                document.getElementById('pair_ptable').innerHTML += "<a>/</a>";
                document.getElementById('pair_ptable').appendChild(input2);
                worker5 = new Worker('src/pseudoPairAnalyzer/worker_analyzer.js');
                document.getElementById("pair_panalyzer").textContent = "End";
                worker5.onmessage = function (event) {
                    if (event.data == "Error") {
                        if (worker5) {
                            worker5.terminate();
                        }
                        worker5 = null;
                        document.getElementById("pair_panalyzer").textContent = "Analyze";
                        if (messageCount_pair_panalyzer > 0) {
                            option_pair_ptable = {
                                valueNames: ["No", "slot", "pslot", "a_slot", "a_pslot", "D", "U", "L", "R", "F", "B"]
                            };
                            list_pair_ptable = new List('pair_ptable', option_pair_ptable);
                        }
                        const error_message = "<br><a>Analyzer terminated due to an error.</a><br>";
                        document.getElementById('pair_ptable').innerHTML += error_message;
                        return;
                    } else if (messageCount_pair_panalyzer === -2) {
                        messageCount_pair_panalyzer++;
                        document.getElementById('pair_ptable').innerHTML += event.data;
                    } else if (messageCount_pair_panalyzer === -1) {
                        messageCount_pair_panalyzer++;
                        document.getElementById("count_pair_panalyzer_max").value = event.data;
                    } else if (event.data === "Finished.") {
                        if (worker5) {
                            worker5.terminate();
                            worker5 = null;
                            document.getElementById("pair_panalyzer").textContent = "Analyze";
                            option_pair_ptable = {
                                valueNames: ["No", "slot", "pslot", "a_slot", "a_pslot", "D", "U", "L", "R", "F", "B"]
                            };
                            list_pair_ptable = new List('pair_ptable', option_pair_ptable);
                            return;
                        }
                    } else {
                        messageCount_pair_panalyzer++;
                        document.querySelector('#pair_panalyzer_result tbody').insertAdjacentHTML('beforeend', event.data);
                        document.getElementById("count_pair_panalyzer").value = messageCount_pair_panalyzer;
                    }
                };
                let cross = false;
                let xcross = false;
                let xxcross = false;
                let xxxcross = false;
                if (option === "cross" || option == "2x" || option === "3x" || option === "4x") {
                    cross = true;
                }
                if (option === "xcross" || option == "2x" || option === "3x" || option === "4x") {
                    xcross = true;
                }
                if (option === "xxcross" || option === "3x" || option === "4x") {
                    xxcross = true;
                }
                if (option === "xxxcross" || option === "4x") {
                    xxxcross = true;
                }
                const args = { scramble: convert(scramble)[0], cross: cross, x: xcross, xx: xxcross, xxx: xxxcross, n: sol_num, rot_set: rot_set };
                worker5.postMessage(args);
            } catch (e) {
                console.log(e.message);
                if (worker5) {
                    worker5.terminate();
                }
                worker5 = null;
                document.getElementById("pair_panalyzer").textContent = "Analyze";
                if (messageCount_pair_panalyzer > 0) {
                    option_pair_ptable = {
                        valueNames: ["No", "slot", "pslot", "a_slot", "a_pslot", "D", "U", "L", "R", "F", "B"]
                    };
                    list_pair_ptable = new List('pair_ptable', option_pair_ptable);
                }
                const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                document.getElementById('pair_ptable').innerHTML += error_message;
                return;
            }
        }

        function pair_psolve(slot_option, pslot_option, a_slot_option, a_pslot_option, rotation_option) {
            document.getElementById("solver").value = "PF2L_pair";
            document.getElementById('rot').value = rotation_option;
            document.getElementById('pslot_edge2').value = slot_option;
            updateDropdown3();
            document.getElementById('pslot_corner2').value = pslot_option;
            updateDropdown4();
            document.getElementById('pair_pslot_edge').value = a_slot_option;
            document.getElementById('pair_pslot_corner').value = a_pslot_option;
            document.getElementById('num').value = 20;
            document.getElementById('len').value = 20;
            document.getElementById('premove').value = '';
            document.getElementById('rot_count').value = '0';
            initializeForAnalyzer(defaultValues['PF2L_pair']);
            updateUrlParams();
            if (worker) {
                startWorker();
            }
            startWorker();
        }

        function eo_analyze() {
            try {
                if (worker6) {
                    worker6.terminate();
                    worker6 = null;
                    document.getElementById("eo_analyzer").textContent = "Analyze";
                    if (messageCount_eo_analyzer > 0) {
                        option_eo_table = {
                            valueNames: ["No", "slot", "D", "D1", "U", "U1", "L", "L1", "R", "R1", "F", "F1", "B", "B1"]
                        };
                        list_eo_table = new List('eo_table', option_eo_table);
                    }
                    return;
                }

                if (typeof convert !== "function") {
                    alert("Error: The required function is not initialized. Please reload the page manually.");
                    document.getElementById("eo_analyzer").textContent = "Analyze";
                    const error_message = "<br><a>Analyzer terminated due to an error.</a><br>";
                    document.getElementById('eo_table').innerHTML += error_message;
                    return;
                }
                const content = "<a>Hint: Click a cell to start the search with that condition, and click the header to sort.</a><br>";
                document.getElementById('eo_table').innerHTML = content;
                let scr = document.getElementById("scr").value;
                const scramble = scr_fix(scr);
                const option = document.getElementById('eo_analyzer_option').value;
                const checkboxes = document.querySelectorAll('#eo_analyzer_rotation_option .eo_analyzer');
                const values = [];
                checkboxes.forEach(function (checkbox) {
                    if (checkbox.checked) {
                        values.push(checkbox.value);
                    }
                });
                const rot_set = values.join('');
                const sol_num = document.getElementById("eo_analyzer_num").value;
                messageCount_eo_analyzer = -2;
                document.getElementById('eo_table').innerHTML += "<a>Solved: </a>";
                const input = document.createElement('input');
                input.type = 'text';
                input.id = 'count_eo_analyzer';
                input.readOnly = true;
                const input2 = document.createElement('input');
                input2.type = 'text';
                input2.id = 'count_eo_analyzer_max';
                input2.readOnly = true;
                document.getElementById('eo_table').appendChild(input);
                document.getElementById('eo_table').innerHTML += "<a>/</a>";
                document.getElementById('eo_table').appendChild(input2);
                worker6 = new Worker('src/EOCrossAnalyzer/worker_analyzer.js');
                document.getElementById("eo_analyzer").textContent = "End";
                worker6.onmessage = function (event) {
                    if (event.data == "Error") {
                        if (worker6) {
                            worker6.terminate();
                        }
                        worker6 = null;
                        document.getElementById("eo_analyzer").textContent = "Analyze";
                        if (messageCount_eo_analyzer > 0) {
                            option_eo_table = {
                                valueNames: ["No", "slot", "D", "D1", "U", "U1", "L", "L1", "R", "R1", "F", "F1", "B", "B1"]
                            };
                            list_eo_table = new List('eo_table', option_eo_table);
                        }
                        const error_message = "<br><a>Error: Analyzer terminated due to an error.</a><br>";
                        document.getElementById('eo_table').innerHTML += error_message;
                        return;
                    } else if (messageCount_eo_analyzer === -2) {
                        messageCount_eo_analyzer++;
                        document.getElementById('eo_table').innerHTML += event.data;
                    } else if (messageCount_eo_analyzer === -1) {
                        messageCount_eo_analyzer++;
                        document.getElementById("count_eo_analyzer_max").value = event.data;
                    } else if (event.data === "Finished.") {
                        if (worker6) {
                            worker6.terminate();
                            worker6 = null;
                            document.getElementById("eo_analyzer").textContent = "Analyze";
                            option_eo_table = {
                                valueNames: ["No", "slot", "D", "D1", "U", "U1", "L", "L1", "R", "R1", "F", "F1", "B", "B1"]
                            };
                            list_eo_table = new List('eo_table', option_eo_table);
                            return;
                        }
                    } else {
                        messageCount_eo_analyzer++;
                        document.querySelector('#eo_analyzer_result tbody').insertAdjacentHTML('beforeend', event.data);
                        document.getElementById("count_eo_analyzer").value = messageCount_eo_analyzer;
                    }
                };
                let cross = false;
                let xcross = false;
                let xxcross = false;
                let xxxcross = false;
                if (option === "cross" || option == "2x" || option === "3x" || option === "4x") {
                    cross = true;
                }
                if (option === "xcross" || option == "2x" || option === "3x" || option === "4x") {
                    xcross = true;
                }
                if (option === "xxcross" || option === "3x" || option === "4x") {
                    xxcross = true;
                }
                if (option === "xxxcross" || option === "4x") {
                    xxxcross = true;
                }
                const args = { scramble: convert(scramble)[0], cross: cross, x: xcross, xx: xxcross, xxx: xxxcross, n: sol_num, rot_set: rot_set };
                worker6.postMessage(args);
            } catch (e) {
                console.log(e.message);
                if (worker6) {
                    worker6.terminate();
                }
                worker6 = null;
                document.getElementById("eo_analyzer").textContent = "Analyze";
                if (messageCount_eo_analyzer > 0) {
                    option_eo_table = {
                        valueNames: ["No", "slot", "D", "D1", "U", "U1", "L", "L1", "R", "R1", "F", "F1", "B", "B1"]
                    };
                    list_eo_table = new List('eo_table', option_eo_table);
                }
                const error_message = "<br><a>AError: nalyzer terminated due to an error.</a><br>";
                document.getElementById('eo_table').innerHTML += error_message;
                return;
            }
        }

        function eo_solve(slot_option, rotation_option) {
            document.getElementById("solver").value = "EOCross";
            document.getElementById('rot').value = rotation_option;
            document.getElementById('slot_eo').value = slot_option;
            document.getElementById('num').value = 20;
            document.getElementById('len').value = 20;
            document.getElementById('premove').value = '';
            document.getElementById('rot_count').value = '0';
            initializeForAnalyzer(defaultValues['EOCross']);
            updateUrlParams();
            if (worker) {
                startWorker();
            }
            startWorker();
        }

        function add(s) {
            document.getElementById('scr').value += "\n" + s;
            save();
        }

        document.getElementById('header').addEventListener('click', function () {
            const url = new URL(window.location.href);
            url.search = '';
            window.location.href = url;
        });

        const details_analyzer = document.getElementById("analyze");
        const details_eo_analyzer = document.getElementById("eo_analyze");
        const details_panalyzer = document.getElementById("panalyze");
        const details_pair_analyzer = document.getElementById("pair_analyze");
        const details_pair_panalyzer = document.getElementById("pair_panalyze");
        const details_mask_options = document.getElementById("maskOptions");
        const details_preview = document.getElementById("details_preview");
        const details_advanced_settings = document.getElementById("advancedSettings");
        const summary_analyzer = document.getElementById("summary_analyzer");
        const summary_eo_analyzer = document.getElementById("summary_eo_analyzer");
        const summary_panalyzer = document.getElementById("summary_panalyzer");
        const summary_pair_analyzer = document.getElementById("summary_pair_analyzer");
        const summary_pair_panalyzer = document.getElementById("summary_pair_panalyzer");
        const summary_mask_options = document.getElementById("summaryMaskOptions");
        const summary_preview = document.getElementById("summary_preview");
        const summary_advanced_settings = document.getElementById("summaryAdvancedSettings");

        details_analyzer.addEventListener('toggle', () => {
            if (details_analyzer.open) {
                summary_analyzer.textContent = "Hide Analyzer";
            } else {
                summary_analyzer.textContent = "Show Analyzer";
            }
        });

        details_eo_analyzer.addEventListener('toggle', () => {
            if (details_eo_analyzer.open) {
                summary_eo_analyzer.textContent = "Hide Analyzer";
            } else {
                summary_eo_analyzer.textContent = "Show Analyzer";
            }
        });

        details_panalyzer.addEventListener('toggle', () => {
            if (details_panalyzer.open) {
                summary_panalyzer.textContent = "Hide Analyzer";
            } else {
                summary_panalyzer.textContent = "Show Analyzer";
            }
        });

        details_pair_analyzer.addEventListener('toggle', () => {
            if (details_pair_analyzer.open) {
                summary_pair_analyzer.textContent = "Hide Analyzer";
            } else {
                summary_pair_analyzer.textContent = "Show Analyzer";
            }
        });

        details_pair_panalyzer.addEventListener('toggle', () => {
            if (details_pair_panalyzer.open) {
                summary_pair_panalyzer.textContent = "Hide Analyzer";
            } else {
                summary_pair_panalyzer.textContent = "Show Analyzer";
            }
        });

        details_mask_options.addEventListener('toggle', () => {
            if (details_mask_options.open) {
                summary_mask_options.textContent = "Hide Stickering Settings";
            } else {
                summary_mask_options.textContent = "Show Stickering Settings";
            }
        });

        details_preview.addEventListener('toggle', () => {
            if (details_preview.open) {
                summary_preview.textContent = "Hide Preview";
            } else {
                summary_preview.textContent = "Show Preview";
            }
        });

        details_advanced_settings.addEventListener('toggle', () => {
            if (details_advanced_settings.open) {
                summary_advanced_settings.textContent = "Hide Advanced Settings";
            } else {
                summary_advanced_settings.textContent = "Show Advanced Settings";
            }
        });

        const selectsMaskOptions = details_mask_options.querySelectorAll('select');

        selectsMaskOptions.forEach(select => {
            select.addEventListener('change', (event) => {
                setMaskTmp();
            });
        });

        document.getElementById('CheckboxAutoMaskSetting').addEventListener('click', function () {
            AutoMaskSetting = document.getElementById('CheckboxAutoMaskSetting').checked;
            if (!AutoMaskSetting) {
                resetStickeringOptions('-');
            }
        });


        window.onload = function () {
            const urlParams = new URLSearchParams(window.location.search);
            const scrambleParam = urlParams.get(idToKeyMap['scr']);
            document.getElementById("result").innerHTML = "";
            if (scrambleParam) {
                const scr = decodeURIComponent(scrambleParam.replace(/_/g, ' ').replace(/-/g, '\''));
                document.getElementById('scr').value = scr;
                const sol_num = urlParams.get('index');
                const sol = urlParams.get('sol');
                if (sol_num && sol) {
                    messageCount = Number(sol_num) - 1;
                    const sol_fixed = sol.replace(/_/g, ' ').replace(/-/g, '\'');
                    sol_input = true;
                    appendSol(scr, sol_fixed);
                    sol_input = false;
                    document.getElementById("countLine").value = 1;
                } else {
                    document.getElementById("countLine").value = 0;
                }
            }
            document.getElementById('scr').value = scrambleParam ? decodeURIComponent(scrambleParam.replace(/_/g, ' ').replace(/-/g, '\'')) : '';
            if (scrambleParam === '') {
                document.getElementById("reverse").classList.add("hidden");
                document.getElementById("mirror").classList.add("hidden");
            }
            undoButton.classList.add("hidden_small");
            redoButton.classList.add("hidden_small");
            setParamsFromUrl(urlParams);
            save();
        };
    </script>
</body>

</html>